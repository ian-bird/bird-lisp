(define list (assemble '((var-arg) (assign arg# 0 0) ($ 0) halt)))

(define count (assemble '((assign arg# 0 0) (code (assign arg# 0 0) (assign arg# 1 1) (quote ()) (assign prev 2) (eq? $ 0 $ 2) (assign prev 3) (branch $ 3 15) (env-ref count-tco) (assign prev 4) (cdr $ 0) (assign prev 5) (+ $ 1 1) (assign prev 6) (tailcall $ 4 $ 5 $ 6) halt ($ 1) halt) (assign prev 1) (make-env count-tco) (assign prev 2) (make-closure $ 1 $ 2) (assign prev 3) (label count-tco $ 3) (assign prev 4) (gosub count-tco $ 0 0) (assign prev 5) (tailcall progn $ 4 $ 5) halt)))

(define foldl (assemble '((assign arg# 0 0) (assign arg# 1 1) (assign arg# 2 2) (quote ()) (assign prev 3) (eq? $ 2 $ 3) (assign prev 4) (branch $ 4 16) (car $ 2) (assign prev 5) (gosub $ 0 $ 1 $ 5) (assign prev 6) (cdr $ 2) (assign prev 7) (tailcall foldl $ 0 $ 6 $ 7) halt ($ 1) halt)))

(define flip (assemble '((assign arg# 0 0) (code (assign arg# 0 0) (assign arg# 1 1) (env-ref f) (assign prev 2) (tailcall $ 2 $ 1 $ 0) halt) (assign prev 1) (make-env $ 0 f) (assign prev 2) (make-closure $ 1 $ 2) halt)))

(define reverse (assemble '((assign arg# 0 0) (code (assign arg# 0 0) (assign arg# 1 1) (cons $ 1 $ 0) halt) (assign prev 1) (quote ()) (assign prev 2) (tailcall foldl $ 1 $ 2 $ 0) halt)))

(define append2 (assemble '((assign arg# 0 0) (assign arg# 1 1) (gosub flip cons) (assign prev 2) (gosub reverse $ 0) (assign prev 3) (tailcall foldl $ 2 $ 1 $ 3) halt)))

(define foldr (assemble '((assign arg# 0 0) (assign arg# 1 1) (assign arg# 2 2) (gosub flip $ 0) (assign prev 3) (gosub reverse $ 2) (assign prev 4) (tailcall foldl $ 3 $ 1 $ 4) halt)))

(define map (assemble '((assign arg# 0 0) (assign arg# 1 1) (code (assign arg# 0 0) (assign arg# 1 1) (env-ref fn) (assign prev 2) (gosub $ 2 $ 1) (assign prev 3) (cons $ 3 $ 0) halt) (assign prev 2) (make-env $ 0 fn) (assign prev 3) (make-closure $ 2 $ 3) (assign prev 4) (quote ()) (assign prev 5) (gosub foldl $ 4 $ 5 $ 1) (assign prev 6) (tailcall reverse $ 6) halt)))

(define filter (assemble '((assign arg# 0 0) (assign arg# 1 1) (code (assign arg# 0 0) (assign arg# 1 1) (env-ref fn) (assign prev 2) (gosub $ 2 $ 0) (assign prev 3) (branch $ 3 9) ($ 1) halt (cons $ 0 $ 1) halt) (assign prev 2) (make-env $ 0 fn) (assign prev 3) (make-closure $ 2 $ 3) (assign prev 4) (quote ()) (assign prev 5) (tailcall foldr $ 4 $ 5 $ 1) halt)))

(define even? (assemble '((assign arg# 0 0) (% $ 0 2) (assign prev 1) (eq? 0 $ 1) halt)))

(define last (assemble '((assign arg# 0 0) (cdr $ 0) (assign prev 1) (quote ()) (assign prev 2) (eq? $ 1 $ 2) (assign prev 3) (branch $ 3 12) (cdr $ 0) (assign prev 4) (tailcall last $ 4) halt (car $ 0) halt)))

(define progn (assemble '((var-arg) (assign arg# 0 0) (tailcall last $ 0) halt)))

(define append (assemble '((var-arg) (assign arg# 0 0) (quote ()) (assign prev 1) (tailcall foldr append2 $ 1 $ 0) halt)))

(define identity (assemble '((assign arg# 0 0) ($ 0) halt)))

(define not (assemble '((assign arg# 0 0) (branch $ 0 4) #t halt #f halt)))

(define partial (assemble '((var-arg) (assign arg# 0 0) (code (var-arg) (assign arg# 0 0) (env-ref fn-and-args) (assign prev 1) (car $ 1) (assign prev 2) (env-ref fn-and-args) (assign prev 3) (cdr $ 3) (assign prev 4) (gosub append $ 4 $ 0) (assign prev 5) (tailcall apply $ 2 $ 5) halt) (assign prev 1) (make-env $ 0 fn-and-args) (assign prev 2) (make-closure $ 1 $ 2) halt)))

(define any? (assemble '((assign arg# 0 0) (assign arg# 1 1) (code (assign arg# 0 0) (assign arg# 1 1) (branch $ 0 12) (env-ref f) (assign prev 2) (gosub $ 2 $ 1) (assign prev 3) (branch $ 3 10) #f halt #t halt ($ 0) halt) (assign prev 2) (make-env $ 0 f) (assign prev 3) (make-closure $ 2 $ 3) (assign prev 4) (tailcall foldl $ 4 #f $ 1) halt)))

(define all? (assemble '((assign arg# 0 0) (assign arg# 1 1) (code (assign arg# 0 0) (assign arg# 1 1) (gosub not $ 0) (assign prev 2) (branch $ 2 16) (env-ref f) (assign prev 3) (gosub $ 3 $ 1) (assign prev 4) (gosub not $ 4) (assign prev 5) (branch $ 5 14) #t halt #f halt #f halt) (assign prev 2) (make-env $ 0 f) (assign prev 3) (make-closure $ 2 $ 3) (assign prev 4) (tailcall foldl $ 4 #t $ 1) halt)))

(define walk (assemble '((assign arg# 0 0) (assign arg# 1 1) (assign arg# 2 2) (gosub $ 0 $ 2) (assign prev 3) (branch $ 3 12) (gosub partial walk $ 0 $ 1) (assign prev 4) (gosub map $ 4 $ 2) (assign prev 5) (tailcall $ 1 $ 5) halt (tailcall $ 0 $ 2) halt)))

(define zip (assemble '((var-arg) (assign arg# 0 0) (code (assign arg# 0 0) (quote ()) (assign prev 1) (eq? $ 0 $ 1) halt) (assign prev 1) (gosub any? $ 1 $ 0) (assign prev 2) (branch $ 2 15) (gosub map car $ 0) (assign prev 3) (gosub map cdr $ 0) (assign prev 4) (gosub apply zip $ 4) (assign prev 5) (cons $ 3 $ 5) halt (quote ()) halt)))

(define >= (assemble '((var-arg) (assign arg# 0 0) (code (assign arg# 0 0) (> $ 0 0) (assign prev 1) (branch $ 1 11) (eq? $ 0 0) (assign prev 2) (branch $ 2 9) #f halt #t halt #t halt) (assign prev 1) (gosub partial apply -) (assign prev 2) (cdr $ 0) (assign prev 3) (gosub zip $ 0 $ 3) (assign prev 4) (gosub map $ 2 $ 4) (assign prev 5) (tailcall all? $ 1 $ 5) halt)))

(define <= (assemble '((var-arg) (assign arg# 0 0) (code (assign arg# 0 0) (> 0 $ 0) (assign prev 1) (branch $ 1 11) (eq? $ 0 0) (assign prev 2) (branch $ 2 9) #f halt #t halt #t halt) (assign prev 1) (gosub partial apply -) (assign prev 2) (cdr $ 0) (assign prev 3) (gosub zip $ 0 $ 3) (assign prev 4) (gosub map $ 2 $ 4) (assign prev 5) (tailcall all? $ 1 $ 5) halt)))

(define take-last (assemble '((assign arg# 0 0) (assign arg# 1 1) (quote ()) (assign prev 2) (eq? $ 1 $ 2) (assign prev 3) (branch $ 3 18) (gosub count $ 1) (assign prev 4) (gosub >= $ 0 $ 4) (assign prev 5) (branch $ 5 16) (cdr $ 1) (assign prev 6) (tailcall take-last $ 0 $ 6) halt ($ 1) halt (quote ()) halt)))

(define inc (assemble '((assign arg# 0 0) (+ $ 0 1) halt)))

(define dec (assemble '((assign arg# 0 0) (- $ 0 1) halt)))

(define take (assemble '((assign arg# 0 0) (assign arg# 1 1) (> $ 0 0) (assign prev 2) (gosub not $ 2) (assign prev 3) (branch $ 3 46) (quote ()) (assign prev 4) (eq? $ 1 $ 4) (assign prev 5) (gosub not $ 5) (assign prev 6) (gosub not $ 6) (assign prev 7) (branch $ 7 31) (gosub not #f) (assign prev 8) (branch $ 8 21) (quote ()) halt (car $ 1) (assign prev 9) (gosub dec $ 0) (assign prev 10) (cdr $ 1) (assign prev 11) (gosub take $ 10 $ 11) (assign prev 12) (cons $ 9 $ 12) halt (gosub not #t) (assign prev 13) (branch $ 13 36) (quote ()) halt (car $ 1) (assign prev 14) (gosub dec $ 0) (assign prev 15) (cdr $ 1) (assign prev 16) (gosub take $ 15 $ 16) (assign prev 17) (cons $ 14 $ 17) halt (gosub not #t) (assign prev 18) (branch $ 18 51) (quote ()) halt (car $ 1) (assign prev 19) (gosub dec $ 0) (assign prev 20) (cdr $ 1) (assign prev 21) (gosub take $ 20 $ 21) (assign prev 22) (cons $ 19 $ 22) halt)))

(define drop (assemble '((assign arg# 0 0) (assign arg# 1 1) (> $ 0 0) (assign prev 2) (gosub not $ 2) (assign prev 3) (branch $ 3 38) (quote ()) (assign prev 4) (eq? $ 1 $ 4) (assign prev 5) (gosub not $ 5) (assign prev 6) (gosub not $ 6) (assign prev 7) (branch $ 7 27) (gosub not #f) (assign prev 8) (branch $ 8 21) ($ 1) halt (gosub dec $ 0) (assign prev 9) (cdr $ 1) (assign prev 10) (tailcall drop $ 9 $ 10) halt (gosub not #t) (assign prev 11) (branch $ 11 32) ($ 1) halt (gosub dec $ 0) (assign prev 12) (cdr $ 1) (assign prev 13) (tailcall drop $ 12 $ 13) halt (gosub not #t) (assign prev 14) (branch $ 14 43) ($ 1) halt (gosub dec $ 0) (assign prev 15) (cdr $ 1) (assign prev 16) (tailcall drop $ 15 $ 16) halt)))

(define partition (assemble '((assign arg# 0 0) (assign arg# 1 1) (assign arg# 2 2) (gosub count $ 2) (assign prev 3) (gosub >= $ 3 $ 0) (assign prev 4) (branch $ 4 10) (quote ()) halt (gosub take $ 0 $ 2) (assign prev 5) (gosub drop $ 1 $ 2) (assign prev 6) (gosub partition $ 0 $ 1 $ 6) (assign prev 7) (cons $ 5 $ 7) halt)))

(define mapcat (assemble '((assign arg# 0 0) (assign arg# 1 1) (gosub map $ 0 $ 1) (assign prev 2) (tailcall apply append $ 2) halt)))

;; too long
(define replace-subseq-2 (assemble '((assign arg# 0 0) (assign arg# 1 1) (gosub count $ 1) (assign prev 2) (> 2 $ 2) (assign prev 3) (branch $ 3 72) (car $ 1) (assign prev 4) (cdr $ 1) (assign prev 5) (car $ 5) (assign prev 6) (gosub $ 0 $ 4 $ 6) (assign prev 7) (branch $ 7 41) (car $ 1) (assign prev 8) (car $ 1) (assign prev 9) (cdr $ 1) (assign prev 10) (car $ 10) (assign prev 11) (gosub $ 0 $ 9 $ 11) (assign prev 12) (branch $ 12 33) (cdr $ 1) (assign prev 13) (gosub replace-subseq-2 $ 0 $ 13) (assign prev 14) (cons $ 8 $ 14) halt (cdr $ 1) (assign prev 15) (cdr $ 15) (assign prev 16) (gosub replace-subseq-2 $ 0 $ 16) (assign prev 17) (cons $ 8 $ 17) halt (car $ 1) (assign prev 18) (cdr $ 1) (assign prev 19) (car $ 19) (assign prev 20) (gosub $ 0 $ 18 $ 20) (assign prev 21) (car $ 1) (assign prev 22) (cdr $ 1) (assign prev 23) (car $ 23) (assign prev 24) (gosub $ 0 $ 22 $ 24) (assign prev 25) (branch $ 25 64) (cdr $ 1) (assign prev 26) (gosub replace-subseq-2 $ 0 $ 26) (assign prev 27) (cons $ 21 $ 27) halt (cdr $ 1) (assign prev 28) (cdr $ 28) (assign prev 29) (gosub replace-subseq-2 $ 0 $ 29) (assign prev 30) (cons $ 21 $ 30) halt ($ 1) halt)))

(define subseq-post-walk-2 (assemble '((assign arg# 0 0) (assign arg# 1 1) (atom? $ 1) (assign prev 2) (branch $ 2 11) (gosub partial subseq-post-walk-2 $ 0) (assign prev 3) (gosub map $ 3 $ 1) (assign prev 4) (tailcall replace-subseq-2 $ 0 $ 4) halt ($ 1) halt)))

(define alist (assemble '((assign arg# 0 0) (gosub count $ 0) (assign prev 1) (gosub even? $ 1) (assign prev 2) (branch $ 2 8) (quote ()) halt (gosub partial apply cons) (assign prev 3) (gosub partition 2 2 $ 0) (assign prev 4) (tailcall map $ 3 $ 4) halt)))

(define get (assemble '((assign arg# 0 0) (assign arg# 1 1) (quote ()) (assign prev 2) (eq? $ 0 $ 2) (assign prev 3) (branch $ 3 22) (car $ 0) (assign prev 4) (car $ 4) (assign prev 5) (eq? $ 5 $ 1) (assign prev 6) (branch $ 6 18) (cdr $ 0) (assign prev 7) (tailcall get $ 7 $ 1) halt (car $ 0) (assign prev 8) (cdr $ 8) halt (quote ()) halt)))

(define nth (assemble '((assign arg# 0 0) (assign arg# 1 1) (gosub drop $ 1 $ 0) (assign prev 2) (car $ 2) halt)))

(define update (assemble '((assign arg# 0 0) (assign arg# 1 1) (assign arg# 2 2) (gosub get $ 0 $ 1) (assign prev 3) (gosub $ 2 $ 3) (assign prev 4) (cons $ 1 $ 4) (assign prev 5) (cons $ 5 $ 0) halt)))

(define constantly (assemble '((assign arg# 0 0) (code (assign arg# 0 0) (env-ref x) halt) (assign prev 1) (make-env $ 0 x) (assign prev 2) (make-closure $ 1 $ 2) halt)))

(define unassoc (assemble '((assign arg# 0 0) (assign arg# 1 1) (code (assign arg# 0 0) (car $ 0) (assign prev 1) (env-ref k) (assign prev 2) (eq? $ 1 $ 2) (assign prev 3) (tailcall not $ 3) halt) (assign prev 2) (make-env $ 1 k) (assign prev 3) (make-closure $ 2 $ 3) (assign prev 4) (tailcall filter $ 4 $ 0) halt)))

(define range (assemble '((assign arg# 0 0) (assign arg# 1 1) (assign arg# 2 2) (> $ 1 $ 0) (assign prev 3) (branch $ 3 8) (quote ()) halt (+ $ 0 $ 2) (assign prev 4) (gosub range $ 4 $ 1 $ 2) (assign prev 5) (cons $ 0 $ 5) halt)))

(define caar (assemble '((assign arg# 0 0) (car $ 0) (assign prev 1) (car $ 1) halt)))

(define cadr (assemble '((assign arg# 0 0) (cdr $ 0) (assign prev 1) (car $ 1) halt)))

(define cdar (assemble '((assign arg# 0 0) (car $ 0) (assign prev 1) (cdr $ 1) halt)))

(define cddr (assemble '((assign arg# 0 0) (cdr $ 0) (assign prev 1) (cdr $ 1) halt)))

(define list? (assemble '((assign arg# 0 0) (atom? $ 0) (assign prev 1) (tailcall not $ 1) halt)))

(define halt (assemble '((assign arg# 0 0) ($ 0) halt)))

(define drop-last (assemble '((assign arg# 0 0) (gosub count $ 0) (assign prev 1) (gosub dec $ 1) (assign prev 2) (tailcall take $ 2 $ 0) halt)))

(define match-head (assemble '((assign arg# 0 0) (assign arg# 1 1) (quote ()) (assign prev 2) (eq? $ 0 $ 2) (assign prev 3) (branch $ 3 60) (quote ()) (assign prev 4) (eq? $ 1 $ 4) (assign prev 5) (branch $ 5 58) (car $ 0) (assign prev 6) (gosub list? $ 6) (assign prev 7) (branch $ 7 45) (car $ 0) (assign prev 8) (quote ,) (assign prev 9) (eq? $ 8 $ 9) (assign prev 10) (branch $ 10 39) (car $ 0) (assign prev 11) (car $ 1) (assign prev 12) (eq? $ 11 $ 12) (assign prev 13) (branch $ 13 33) #f halt (cdr $ 0) (assign prev 14) (cdr $ 1) (assign prev 15) (tailcall match-head $ 14 $ 15) halt (gosub cddr $ 0) (assign prev 16) (cdr $ 1) (assign prev 17) (tailcall match-head $ 16 $ 17) halt (car $ 1) (assign prev 18) (gosub list? $ 18) (assign prev 19) (branch $ 19 52) #f halt (car $ 0) (assign prev 20) (car $ 1) (assign prev 21) (tailcall match? $ 20 $ 21) halt #f halt ($ 1) halt)))

;; too long
(define match-tail (assemble '((assign arg# 0 0) (assign arg# 1 1) (code (assign arg# 0 0) (code (assign arg# 0 0) (env-ref reversed) (assign prev 1) (gosub match-head $ 0 $ 1) (assign prev 2) (tailcall progn $ 2) halt) (assign prev 1) (make-env $ 0 reversed) (assign prev 2) (make-closure $ 1 $ 2) (assign prev 3) (code (assign arg# 0 0) (code (assign arg# 0 0) (assign arg# 1 1) (quote ()) (assign prev 2) (eq? $ 0 $ 2) (assign prev 3) (gosub not $ 3) (assign prev 4) (gosub not $ 4) (assign prev 5) (branch $ 5 64) (car $ 0) (assign prev 6) (env-ref unquote) (assign prev 7) (eq? $ 6 $ 7) (assign prev 8) (gosub not $ 8) (assign prev 9) (branch $ 9 42) (gosub not #f) (assign prev 10) (branch $ 10 34) (quote ,) (assign prev 11) (eq? $ 1 $ 11) (assign prev 12) (branch $ 12 30) (cons $ 1 $ 0) halt (env-ref unquote) (assign prev 13) (cons $ 13 $ 0) halt (quote ,) (assign prev 14) (cdr $ 0) (assign prev 15) (cons $ 1 $ 15) (assign prev 16) (cons $ 14 $ 16) halt (gosub not #t) (assign prev 17) (branch $ 17 56) (quote ,) (assign prev 18) (eq? $ 1 $ 18) (assign prev 19) (branch $ 19 52) (cons $ 1 $ 0) halt (env-ref unquote) (assign prev 20) (cons $ 20 $ 0) halt (quote ,) (assign prev 21) (cdr $ 0) (assign prev 22) (cons $ 1 $ 22) (assign prev 23) (cons $ 21 $ 23) halt (gosub not #t) (assign prev 24) (branch $ 24 78) (quote ,) (assign prev 25) (eq? $ 1 $ 25) (assign prev 26) (branch $ 26 74) (cons $ 1 $ 0) halt (env-ref unquote) (assign prev 27) (cons $ 27 $ 0) halt (quote ,) (assign prev 28) (cdr $ 0) (assign prev 29) (cons $ 1 $ 29) (assign prev 30) (cons $ 28 $ 30) halt) (assign prev 1) (make-env $ 0 unquote) (assign prev 2) (make-closure $ 1 $ 2) (assign prev 3) (quote ()) (assign prev 4) (env-ref template) (assign prev 5) (gosub foldl $ 3 $ 4 $ 5) (assign prev 6) (tailcall progn $ 6) halt) (assign prev 4) (make-env template) (assign prev 5) (make-closure $ 4 $ 5) (assign prev 6) (gensym) (assign prev 7) (gosub $ 6 $ 7) (assign prev 8) (tailcall $ 3 $ 8) halt) (assign prev 2) (make-env $ 0 template) (assign prev 3) (make-closure $ 2 $ 3) (assign prev 4) (gosub reverse $ 1) (assign prev 5) (tailcall $ 4 $ 5) halt)))

(define match-centre (assemble '((assign arg# 0 0) (assign arg# 1 1) (quote ()) (assign prev 2) (eq? $ 0 $ 2) (assign prev 3) (branch $ 3 27) (quote ()) (assign prev 4) (eq? $ 1 $ 4) (assign prev 5) (branch $ 5 25) (gosub match-head $ 0 $ 1) (assign prev 6) (eq? $ 6 #f) (assign prev 7) (gosub not $ 7) (assign prev 8) (branch $ 8 23) (cdr $ 1) (assign prev 9) (tailcall match-centre $ 0 $ 9) halt (tailcall match-head $ 0 $ 1) halt #f halt ($ 1) halt)))

(define split (assemble '((assign arg# 0 0) (assign arg# 1 1) (code (assign arg# 0 0) (assign arg# 1 1) (env-ref on) (assign prev 2) (eq? $ 0 $ 2) (assign prev 3) (branch $ 3 15) (car $ 1) (assign prev 4) (cons $ 0 $ 4) (assign prev 5) (cdr $ 1) (assign prev 6) (cons $ 5 $ 6) halt (quote ()) (assign prev 7) (cons $ 7 $ 1) halt) (assign prev 2) (make-env $ 1 on) (assign prev 3) (make-closure $ 2 $ 3) (assign prev 4) (quote (())) (assign prev 5) (tailcall foldr $ 4 $ 5 $ 0) halt)))

;; too long
(define match? (assemble '((assign arg# 0 0) (assign arg# 1 1) (atom? $ 1) (assign prev 2) (branch $ 2 27) (code (assign arg# 0 0) (code (assign arg# 0 0) (code (assign arg# 0 0) (code (assign arg# 0 0) (env-ref head-matches?) (assign prev 1) (gosub not $ 1) (assign prev 2) (branch $ 2 26) (env-ref tail-matches?) (assign prev 3) (gosub not $ 3) (assign prev 4) (branch $ 4 22) (gosub not $ 0) (assign prev 5) (branch $ 5 18) (gosub not #f) (assign prev 6) (tailcall progn $ 6) halt (gosub not #t) (assign prev 7) (tailcall progn $ 7) halt (gosub not #t) (assign prev 8) (tailcall progn $ 8) halt (gosub not #t) (assign prev 9) (tailcall progn $ 9) halt) (assign prev 1) (make-env head-matches? $ 0 tail-matches?) (assign prev 2) (make-closure $ 1 $ 2) (assign prev 3) (env-ref actual-groups) (assign prev 4) (gosub count $ 4) (assign prev 5) (> $ 5 2) (assign prev 6) (branch $ 6 16) (tailcall $ 3 #t) halt (code (assign arg# 0 0) (assign arg# 1 1) (atom? $ 0) (assign prev 2) (branch $ 2 7) (tailcall match-centre $ 1 $ 0) halt ($ 0) halt) (assign prev 7) (env-ref actual-groups) (assign prev 8) (gosub last $ 8) (assign prev 9) (env-ref actual-groups) (assign prev 10) (car $ 10) (assign prev 11) (env-ref arg) (assign prev 12) (gosub match-head $ 11 $ 12) (assign prev 13) (gosub match-tail $ 9 $ 13) (assign prev 14) (env-ref actual-groups) (assign prev 15) (cdr $ 15) (assign prev 16) (gosub drop-last $ 16) (assign prev 17) (gosub foldl $ 7 $ 14 $ 17) (assign prev 18) (tailcall $ 3 $ 18) halt) (assign prev 1) (make-env $ 0 head-matches? arg actual-groups) (assign prev 2) (make-closure $ 1 $ 2) (assign prev 3) (env-ref actual-groups) (assign prev 4) (gosub last $ 4) (assign prev 5) (quote ()) (assign prev 6) (eq? $ 5 $ 6) (assign prev 7) (branch $ 7 33) (env-ref actual-groups) (assign prev 8) (gosub last $ 8) (assign prev 9) (env-ref arg) (assign prev 10) (gosub match-tail $ 9 $ 10) (assign prev 11) (eq? $ 11 #f) (assign prev 12) (gosub not $ 12) (assign prev 13) (branch $ 13 31) (tailcall $ 3 #f) halt (tailcall $ 3 #t) halt (tailcall $ 3 #t) halt) (assign prev 1) (make-env $ 0 actual-groups arg) (assign prev 2) (make-closure $ 1 $ 2) (assign prev 3) (car $ 0) (assign prev 4) (quote ()) (assign prev 5) (eq? $ 4 $ 5) (assign prev 6) (branch $ 6 29) (car $ 0) (assign prev 7) (env-ref arg) (assign prev 8) (gosub match-head $ 7 $ 8) (assign prev 9) (eq? $ 9 #f) (assign prev 10) (gosub not $ 10) (assign prev 11) (branch $ 11 27) (tailcall $ 3 #f) halt (tailcall $ 3 #t) halt (tailcall $ 3 #t) halt) (assign prev 3) (make-env $ 1 arg) (assign prev 4) (make-closure $ 3 $ 4) (assign prev 5) (code (assign arg# 0 0) (code (assign arg# 0 0) (assign arg# 1 1) (quote ()) (assign prev 2) (eq? $ 0 $ 2) (assign prev 3) (gosub not $ 3) (assign prev 4) (gosub not $ 4) (assign prev 5) (branch $ 5 60) (env-ref splicing-unquote) (assign prev 6) (car $ 0) (assign prev 7) (eq? $ 6 $ 7) (assign prev 8) (gosub not $ 8) (assign prev 9) (branch $ 9 40) (gosub not #f) (assign prev 10) (branch $ 10 34) (quote ,@) (assign prev 11) (eq? $ 1 $ 11) (assign prev 12) (branch $ 12 30) (cons $ 1 $ 0) halt (env-ref splicing-unquote) (assign prev 13) (cons $ 13 $ 0) halt (quote ,@) (assign prev 14) (cdr $ 0) (assign prev 15) (cons $ 14 $ 15) halt (gosub not #t) (assign prev 16) (branch $ 16 54) (quote ,@) (assign prev 17) (eq? $ 1 $ 17) (assign prev 18) (branch $ 18 50) (cons $ 1 $ 0) halt (env-ref splicing-unquote) (assign prev 19) (cons $ 19 $ 0) halt (quote ,@) (assign prev 20) (cdr $ 0) (assign prev 21) (cons $ 20 $ 21) halt (gosub not #t) (assign prev 22) (branch $ 22 74) (quote ,@) (assign prev 23) (eq? $ 1 $ 23) (assign prev 24) (branch $ 24 70) (cons $ 1 $ 0) halt (env-ref splicing-unquote) (assign prev 25) (cons $ 25 $ 0) halt (quote ,@) (assign prev 26) (cdr $ 0) (assign prev 27) (cons $ 26 $ 27) halt) (assign prev 1) (make-env $ 0 splicing-unquote) (assign prev 2) (make-closure $ 1 $ 2) (assign prev 3) (quote ()) (assign prev 4) (env-ref template) (assign prev 5) (gosub foldl $ 3 $ 4 $ 5) (assign prev 6) (gosub reverse $ 6) (assign prev 7) (tailcall progn $ 7) halt) (assign prev 6) (make-env $ 0 template) (assign prev 7) (make-closure $ 6 $ 7) (assign prev 8) (gensym) (assign prev 9) (gosub $ 8 $ 9) (assign prev 10) (quote ,@) (assign prev 11) (gosub split $ 10 $ 11) (assign prev 12) (tailcall $ 5 $ 12) halt #f halt)))

(define take-while (assemble '((assign arg# 0 0) (assign arg# 1 1) (quote ()) (assign prev 2) (eq? $ 1 $ 2) (assign prev 3) (branch $ 3 22) (car $ 1) (assign prev 4) (gosub $ 0 $ 4) (assign prev 5) (branch $ 5 14) (quote ()) halt (car $ 1) (assign prev 6) (cdr $ 1) (assign prev 7) (gosub take-while $ 0 $ 7) (assign prev 8) (cons $ 6 $ 8) halt (quote ()) halt)))

;; too long
(define extract-values-from-template (assemble '((assign arg# 0 0) (quote ()) (assign prev 1) (eq? $ 0 $ 1) (assign prev 2) (branch $ 2 104) (car $ 0) (assign prev 3) (quote ,) (assign prev 4) (eq? $ 3 $ 4) (assign prev 5) (branch $ 5 76) (car $ 0) (assign prev 6) (quote ,@) (assign prev 7) (eq? $ 6 $ 7) (assign prev 8) (branch $ 8 48) (branch #f 40) (car $ 0) (assign prev 9) (gosub list? $ 9) (assign prev 10) (branch $ 10 30) (cdr $ 0) (assign prev 11) (tailcall extract-values-from-template $ 11) halt (car $ 0) (assign prev 12) (gosub extract-values-from-template $ 12) (assign prev 13) (cdr $ 0) (assign prev 14) (gosub extract-values-from-template $ 14) (assign prev 15) (tailcall append $ 13 $ 15) halt (gosub cadr $ 0) (assign prev 16) (gosub cddr $ 0) (assign prev 17) (gosub extract-values-from-template $ 17) (assign prev 18) (cons $ 16 $ 18) halt (branch #t 68) (car $ 0) (assign prev 19) (gosub list? $ 19) (assign prev 20) (branch $ 20 58) (cdr $ 0) (assign prev 21) (tailcall extract-values-from-template $ 21) halt (car $ 0) (assign prev 22) (gosub extract-values-from-template $ 22) (assign prev 23) (cdr $ 0) (assign prev 24) (gosub extract-values-from-template $ 24) (assign prev 25) (tailcall append $ 23 $ 25) halt (gosub cadr $ 0) (assign prev 26) (gosub cddr $ 0) (assign prev 27) (gosub extract-values-from-template $ 27) (assign prev 28) (cons $ 26 $ 28) halt (branch #t 96) (car $ 0) (assign prev 29) (gosub list? $ 29) (assign prev 30) (branch $ 30 86) (cdr $ 0) (assign prev 31) (tailcall extract-values-from-template $ 31) halt (car $ 0) (assign prev 32) (gosub extract-values-from-template $ 32) (assign prev 33) (cdr $ 0) (assign prev 34) (gosub extract-values-from-template $ 34) (assign prev 35) (tailcall append $ 33 $ 35) halt (gosub cadr $ 0) (assign prev 36) (gosub cddr $ 0) (assign prev 37) (gosub extract-values-from-template $ 37) (assign prev 38) (cons $ 36 $ 38) halt (quote ()) halt)))

(define none? (assemble '((assign arg# 0 0) (assign arg# 1 1) (gosub any? $ 0 $ 1) (assign prev 2) (tailcall not $ 2) halt)))

;; too long
(define extract-template-value (assemble '((assign arg# 0 0) (assign arg# 1 1) (assign arg# 2 2) (quote ()) (assign prev 3) (eq? $ 0 $ 3) (assign prev 4) (branch $ 4 137) (gosub match? $ 0 $ 2) (assign prev 5) (gosub not $ 5) (assign prev 6) (branch $ 6 135) (quote ()) (assign prev 7) (eq? $ 2 $ 7) (assign prev 8) (branch $ 8 133) (car $ 0) (assign prev 9) (quote ,) (assign prev 10) (eq? $ 9 $ 10) (assign prev 11) (branch $ 11 120) (car $ 0) (assign prev 12) (quote ,@) (assign prev 13) (eq? $ 12 $ 13) (assign prev 14) (branch $ 14 68) (car $ 0) (assign prev 15) (gosub list? $ 15) (assign prev 16) (branch $ 16 43) (cdr $ 0) (assign prev 17) (cdr $ 2) (assign prev 18) (tailcall extract-template-value $ 17 $ 1 $ 18) halt (car $ 0) (assign prev 19) (car $ 2) (assign prev 20) (gosub extract-template-value $ 19 $ 1 $ 20) (assign prev 21) (quote ()) (assign prev 22) (eq? $ 21 $ 22) (assign prev 23) (gosub not $ 23) (assign prev 24) (branch $ 24 62) (cdr $ 0) (assign prev 25) (cdr $ 2) (assign prev 26) (tailcall extract-template-value $ 25 $ 1 $ 26) halt (car $ 0) (assign prev 27) (car $ 2) (assign prev 28) (tailcall extract-template-value $ 27 $ 1 $ 28) halt (gosub cadr $ 0) (assign prev 29) (eq? $ 29 $ 1) (assign prev 30) (branch $ 30 95) (gosub cddr $ 0) (assign prev 31) (code (assign arg# 0 0) (env-ref template) (assign prev 1) (env-ref from) (assign prev 2) (gosub drop $ 0 $ 2) (assign prev 3) (tailcall match? $ 1 $ 3) halt) (assign prev 32) (make-env $ 0 template $ 2 from) (assign prev 33) (make-closure $ 32 $ 33) (assign prev 34) (gosub count $ 2) (assign prev 35) (gosub inc $ 35) (assign prev 36) (gosub range 0 $ 36 1) (assign prev 37) (gosub take-while $ 34 $ 37) (assign prev 38) (gosub last $ 38) (assign prev 39) (gosub drop $ 39 $ 2) (assign prev 40) (tailcall extract-template-value $ 31 $ 1 $ 40) halt (gosub count $ 0) (assign prev 41) (> $ 41 2) (assign prev 42) (branch $ 42 102) ($ 2) halt (code (assign arg# 0 0) (env-ref template) (assign prev 1) (env-ref from) (assign prev 2) (gosub drop $ 0 $ 2) (assign prev 3) (tailcall match? $ 1 $ 3) halt) (assign prev 43) (make-env $ 0 template $ 2 from) (assign prev 44) (make-closure $ 43 $ 44) (assign prev 45) (gosub count $ 2) (assign prev 46) (gosub inc $ 46) (assign prev 47) (gosub range 0 $ 47 1) (assign prev 48) (gosub take-while $ 45 $ 48) (assign prev 49) (gosub last $ 49) (assign prev 50) (tailcall take $ 50 $ 2) halt (gosub cadr $ 0) (assign prev 51) (eq? $ 51 $ 1) (assign prev 52) (branch $ 52 131) (gosub cddr $ 0) (assign prev 53) (cdr $ 2) (assign prev 54) (tailcall extract-template-value $ 53 $ 1 $ 54) halt (car $ 2) halt (quote ()) halt panic halt (quote ()) halt)))

(define flatten (assemble '((assign arg# 0 0) (code (assign arg# 0 0) (gosub list? $ 0) (assign prev 1) (branch $ 1 6) (tailcall list $ 0) halt (tailcall flatten $ 0) halt) (assign prev 1) (tailcall mapcat $ 1 $ 0) halt)))

(define postwalk (assemble '((assign arg# 0 0) (assign arg# 1 1) (gosub list? $ 0) (assign prev 2) (branch $ 2 7) (tailcall $ 1 $ 0) halt (code (assign arg# 0 0) (env-ref fn) (assign prev 1) (tailcall postwalk $ 0 $ 1) halt) (assign prev 3) (make-env $ 1 fn) (assign prev 4) (make-closure $ 3 $ 4) (assign prev 5) (gosub map $ 5 $ 0) (assign prev 6) (tailcall $ 1 $ 6) halt)))

(define prewalk (assemble '((assign arg# 0 0) (assign arg# 1 1) (gosub list? $ 0) (assign prev 2) (branch $ 2 7) (tailcall $ 1 $ 0) halt (code (assign arg# 0 0) (env-ref fn) (assign prev 1) (tailcall prewalk $ 0 $ 1) halt) (assign prev 3) (make-env $ 1 fn) (assign prev 4) (make-closure $ 3 $ 4) (assign prev 5) (gosub $ 1 $ 0) (assign prev 6) (tailcall map $ 5 $ 6) halt)))

(define unique (assemble '((assign arg# 0 0) (code (assign arg# 0 0) (assign arg# 1 1) (gosub partial eq? $ 0) (assign prev 2) (gosub any? $ 2 $ 1) (assign prev 3) (branch $ 3 9) (cons $ 0 $ 1) halt ($ 1) halt) (assign prev 1) (quote ()) (assign prev 2) (tailcall foldr $ 1 $ 2 $ 0) halt)))

(define add-env-ref-calls (assemble '((assign arg# 0 0) (assign arg# 1 1) (gosub list? $ 0) (assign prev 2) (branch $ 2 20) (gosub partial eq? $ 0) (assign prev 3) (gosub any? $ 3 $ 1) (assign prev 4) (branch $ 4 12) ($ 0) halt (quote env-ref) (assign prev 5) (gosub list $ 5) (assign prev 6) (gosub list $ 0) (assign prev 7) (tailcall append $ 6 $ 7) halt (car $ 0) (assign prev 8) (quote make-closure) (assign prev 9) (eq? $ 8 $ 9) (assign prev 10) (branch $ 10 35) (code (assign arg# 0 0) (env-ref free-symbols) (assign prev 1) (tailcall add-env-ref-calls $ 0 $ 1) halt) (assign prev 11) (make-env $ 1 free-symbols) (assign prev 12) (make-closure $ 11 $ 12) (assign prev 13) (tailcall map $ 13 $ 0) halt ($ 0) halt)))

;; too long
(define referenced-free-variables (assemble '((assign arg# 0 0) (assign arg# 1 1) (gosub list? $ 0) (assign prev 2) (gosub not $ 2) (assign prev 3) (branch $ 3 56) (car $ 0) (assign prev 4) (quote quote) (assign prev 5) (eq? $ 4 $ 5) (assign prev 6) (gosub not $ 6) (assign prev 7) (gosub not $ 7) (assign prev 8) (branch $ 8 37) (gosub not #f) (assign prev 9) (branch $ 9 27) (gosub partial eq? $ 0) (assign prev 10) (gosub filter $ 10 $ 1) (assign prev 11) (tailcall unique $ 11) halt (code (assign arg# 0 0) (env-ref free-variables) (assign prev 1) (tailcall referenced-free-variables $ 0 $ 1) halt) (assign prev 12) (make-env $ 1 free-variables) (assign prev 13) (make-closure $ 12 $ 13) (assign prev 14) (gosub mapcat $ 14 $ 0) (assign prev 15) (tailcall unique $ 15) halt (gosub not #t) (assign prev 16) (branch $ 16 46) (gosub partial eq? $ 0) (assign prev 17) (gosub filter $ 17 $ 1) (assign prev 18) (tailcall unique $ 18) halt (code (assign arg# 0 0) (env-ref free-variables) (assign prev 1) (tailcall referenced-free-variables $ 0 $ 1) halt) (assign prev 19) (make-env $ 1 free-variables) (assign prev 20) (make-closure $ 19 $ 20) (assign prev 21) (gosub mapcat $ 21 $ 0) (assign prev 22) (tailcall unique $ 22) halt (gosub not #t) (assign prev 23) (branch $ 23 65) (gosub partial eq? $ 0) (assign prev 24) (gosub filter $ 24 $ 1) (assign prev 25) (tailcall unique $ 25) halt (code (assign arg# 0 0) (env-ref free-variables) (assign prev 1) (tailcall referenced-free-variables $ 0 $ 1) halt) (assign prev 26) (make-env $ 1 free-variables) (assign prev 27) (make-closure $ 26 $ 27) (assign prev 28) (gosub mapcat $ 28 $ 0) (assign prev 29) (tailcall unique $ 29) halt)))

(define extract-labels (assemble '((assign arg# 0 0) (gosub list? $ 0) (assign prev 1) (branch $ 1 6) (quote ()) halt (car $ 0) (assign prev 2) (quote label) (assign prev 3) (eq? $ 2 $ 3) (assign prev 4) (branch $ 4 15) (tailcall mapcat extract-labels $ 0) halt (gosub cadr $ 0) (assign prev 5) (gosub list $ 5) (assign prev 6) (gosub nth $ 0 2) (assign prev 7) (gosub list? $ 7) (assign prev 8) (branch $ 8 28) (quote ()) (assign prev 9) (tailcall append $ 6 $ 9) halt (gosub nth $ 0 2) (assign prev 10) (gosub mapcat extract-labels $ 10) (assign prev 11) (tailcall append $ 6 $ 11) halt)))

(define get-env-variables (assemble '((assign arg# 0 0) (gosub cadr $ 0) (assign prev 1) (gosub nth $ 0 2) (assign prev 2) (code (assign arg# 0 0) (gosub list? $ 0) (assign prev 1) (gosub not $ 1) (assign prev 2) (branch $ 2 29) (car $ 0) (assign prev 3) (quote lambda) (assign prev 4) (eq? $ 3 $ 4) (assign prev 5) (gosub not $ 5) (assign prev 6) (branch $ 6 22) (gosub not #f) (assign prev 7) (branch $ 7 20) ($ 0) halt (quote ()) halt (gosub not #t) (assign prev 8) (branch $ 8 27) ($ 0) halt (quote ()) halt (gosub not #t) (assign prev 9) (branch $ 9 34) ($ 0) halt (quote ()) halt) (assign prev 3) (gosub prewalk $ 2 $ 3) (assign prev 4) (gosub extract-labels $ 4) (assign prev 5) (tailcall append $ 1 $ 5) halt)))

;; too long
(define convert-lambda (assemble '((assign arg# 0 0) (assign arg# 1 1) (code (assign arg# 0 0) (code (assign arg# 0 0) (code (assign arg# 0 0) (code (assign arg# 0 0) (env-ref closed-vars) (assign prev 1) (gosub count $ 1) (assign prev 2) (> $ 2 0) (assign prev 3) (branch $ 3 10) (tailcall progn $ 0) halt (quote make-closure) (assign prev 4) (gosub list $ 4) (assign prev 5) (gosub list $ 0) (assign prev 6) (quote make-env) (assign prev 7) (gosub list $ 7) (assign prev 8) (env-ref closed-vars) (assign prev 9) (gosub append $ 8 $ 9) (assign prev 10) (gosub list $ 10) (assign prev 11) (gosub append $ 5 $ 6 $ 11) (assign prev 12) (tailcall progn $ 12) halt) (assign prev 1) (make-env $ 0 closed-vars) (assign prev 2) (make-closure $ 1 $ 2) (assign prev 3) (quote lambda) (assign prev 4) (gosub list $ 4) (assign prev 5) (env-ref lambda-expression) (assign prev 6) (gosub cadr $ 6) (assign prev 7) (gosub list $ 7) (assign prev 8) (env-ref body) (assign prev 9) (gosub list $ 9) (assign prev 10) (gosub append $ 5 $ 8 $ 10) (assign prev 11) (tailcall $ 3 $ 11) halt) (assign prev 1) (make-env lambda-expression $ 0 body) (assign prev 2) (make-closure $ 1 $ 2) (assign prev 3) (env-ref free-vars) (assign prev 4) (gosub referenced-free-variables $ 0 $ 4) (assign prev 5) (tailcall $ 3 $ 5) halt) (assign prev 1) (make-env lambda-expression free-vars) (assign prev 2) (make-closure $ 1 $ 2) (assign prev 3) (env-ref lambda-expression) (assign prev 4) (gosub nth $ 4 2) (assign prev 5) (env-ref free-vars) (assign prev 6) (gosub append $ 0 $ 6) (assign prev 7) (gosub convert-closures $ 5 $ 7) (assign prev 8) (env-ref free-vars) (assign prev 9) (gosub add-env-ref-calls $ 8 $ 9) (assign prev 10) (tailcall $ 3 $ 10) halt) (assign prev 2) (make-env $ 0 lambda-expression $ 1 free-vars) (assign prev 3) (make-closure $ 2 $ 3) (assign prev 4) (gosub get-env-variables $ 0) (assign prev 5) (tailcall $ 4 $ 5) halt)))

(define mark-var-arg (assemble '((assign arg# 0 0) (assign arg# 1 1) (gosub list? $ 0) (assign prev 2) (gosub not $ 2) (assign prev 3) (branch $ 3 50) (car $ 0) (assign prev 4) (quote lambda) (assign prev 5) (eq? $ 4 $ 5) (assign prev 6) (gosub not $ 6) (assign prev 7) (branch $ 7 41) (gosub cadr $ 0) (assign prev 8) (atom? $ 8) (assign prev 9) (gosub not $ 9) (assign prev 10) (branch $ 10 32) (gosub not #f) (assign prev 11) (branch $ 11 28) ($ 1) halt (quote var-arg) (assign prev 12) (cons $ 12 $ 1) halt (gosub not #t) (assign prev 13) (branch $ 13 37) ($ 1) halt (quote var-arg) (assign prev 14) (cons $ 14 $ 1) halt (gosub not #t) (assign prev 15) (branch $ 15 46) ($ 1) halt (quote var-arg) (assign prev 16) (cons $ 16 $ 1) halt (gosub not #t) (assign prev 17) (branch $ 17 55) ($ 1) halt (quote var-arg) (assign prev 18) (cons $ 18 $ 1) halt)))

(define convert-closures (assemble '((assign arg# 0 0) (assign arg# 1 1) (gosub list? $ 0) (assign prev 2) (branch $ 2 7) ($ 0) halt (car $ 0) (assign prev 3) (quote lambda) (assign prev 4) (eq? $ 3 $ 4) (assign prev 5) (branch $ 5 22) (code (assign arg# 0 0) (env-ref free-vars) (assign prev 1) (tailcall convert-closures $ 0 $ 1) halt) (assign prev 6) (make-env $ 1 free-vars) (assign prev 7) (make-closure $ 6 $ 7) (assign prev 8) (tailcall map $ 8 $ 0) halt (code (assign arg# 0 0) (gosub partial eq? $ 0) (assign prev 1) (env-ref expression) (assign prev 2) (gosub cadr $ 2) (assign prev 3) (tailcall none? $ 1 $ 3) halt) (assign prev 9) (make-env $ 0 expression) (assign prev 10) (make-closure $ 9 $ 10) (assign prev 11) (gosub filter $ 11 $ 1) (assign prev 12) (tailcall convert-lambda $ 0 $ 12) halt)))

;; too long
(define protect-var-args (assemble '((assign arg# 0 0) (gosub list? $ 0) (assign prev 1) (gosub not $ 1) (assign prev 2) (branch $ 2 106) (car $ 0) (assign prev 3) (quote lambda) (assign prev 4) (eq? $ 3 $ 4) (assign prev 5) (gosub not $ 5) (assign prev 6) (branch $ 6 78) (gosub cadr $ 0) (assign prev 7) (atom? $ 7) (assign prev 8) (gosub not $ 8) (assign prev 9) (branch $ 9 50) (gosub not #f) (assign prev 10) (branch $ 10 32) (gosub list? $ 0) (assign prev 11) (branch $ 11 30) ($ 0) halt (tailcall map protect-var-args $ 0) halt (quote lambda) (assign prev 12) (gosub list $ 12) (assign prev 13) (gosub cadr $ 0) (assign prev 14) (gosub list $ 14) (assign prev 15) (gosub append $ 15) (assign prev 16) (gosub list $ 16) (assign prev 17) (gosub cddr $ 0) (assign prev 18) (gosub map protect-var-args $ 18) (assign prev 19) (tailcall append $ 13 $ 17 $ 19) halt (gosub not #t) (assign prev 20) (branch $ 20 60) (gosub list? $ 0) (assign prev 21) (branch $ 21 58) ($ 0) halt (tailcall map protect-var-args $ 0) halt (quote lambda) (assign prev 22) (gosub list $ 22) (assign prev 23) (gosub cadr $ 0) (assign prev 24) (gosub list $ 24) (assign prev 25) (gosub append $ 25) (assign prev 26) (gosub list $ 26) (assign prev 27) (gosub cddr $ 0) (assign prev 28) (gosub map protect-var-args $ 28) (assign prev 29) (tailcall append $ 23 $ 27 $ 29) halt (gosub not #t) (assign prev 30) (branch $ 30 88) (gosub list? $ 0) (assign prev 31) (branch $ 31 86) ($ 0) halt (tailcall map protect-var-args $ 0) halt (quote lambda) (assign prev 32) (gosub list $ 32) (assign prev 33) (gosub cadr $ 0) (assign prev 34) (gosub list $ 34) (assign prev 35) (gosub append $ 35) (assign prev 36) (gosub list $ 36) (assign prev 37) (gosub cddr $ 0) (assign prev 38) (gosub map protect-var-args $ 38) (assign prev 39) (tailcall append $ 33 $ 37 $ 39) halt (gosub not #t) (assign prev 40) (branch $ 40 116) (gosub list? $ 0) (assign prev 41) (branch $ 41 114) ($ 0) halt (tailcall map protect-var-args $ 0) halt (quote lambda) (assign prev 42) (gosub list $ 42) (assign prev 43) (gosub cadr $ 0) (assign prev 44) (gosub list $ 44) (assign prev 45) (gosub append $ 45) (assign prev 46) (gosub list $ 46) (assign prev 47) (gosub cddr $ 0) (assign prev 48) (gosub map protect-var-args $ 48) (assign prev 49) (tailcall append $ 43 $ 47 $ 49) halt)))

;; too long
(define M (assemble '((assign arg# 0 0) (gosub list? $ 0) (assign prev 1) (gosub not $ 1) (assign prev 2) (branch $ 2 91) (gosub count $ 0) (assign prev 3) (eq? $ 3 3) (assign prev 4) (gosub not $ 4) (assign prev 5) (branch $ 5 68) (car $ 0) (assign prev 6) (quote lambda) (assign prev 7) (eq? $ 6 $ 7) (assign prev 8) (gosub not $ 8) (assign prev 9) (branch $ 9 45) (gosub not #f) (assign prev 10) (branch $ 10 27) ($ 0) halt (quote lambda) (assign prev 11) (gosub list $ 11) (assign prev 12) (gosub cadr $ 0) (assign prev 13) (gosub list $ 13) (assign prev 14) (gosub nth $ 0 2) (assign prev 15) (quote halt) (assign prev 16) (gosub T $ 15 $ 16) (assign prev 17) (gosub list $ 17) (assign prev 18) (tailcall append $ 12 $ 14 $ 18) halt (gosub not #t) (assign prev 19) (branch $ 19 50) ($ 0) halt (quote lambda) (assign prev 20) (gosub list $ 20) (assign prev 21) (gosub cadr $ 0) (assign prev 22) (gosub list $ 22) (assign prev 23) (gosub nth $ 0 2) (assign prev 24) (quote halt) (assign prev 25) (gosub T $ 24 $ 25) (assign prev 26) (gosub list $ 26) (assign prev 27) (tailcall append $ 21 $ 23 $ 27) halt (gosub not #t) (assign prev 28) (branch $ 28 73) ($ 0) halt (quote lambda) (assign prev 29) (gosub list $ 29) (assign prev 30) (gosub cadr $ 0) (assign prev 31) (gosub list $ 31) (assign prev 32) (gosub nth $ 0 2) (assign prev 33) (quote halt) (assign prev 34) (gosub T $ 33 $ 34) (assign prev 35) (gosub list $ 35) (assign prev 36) (tailcall append $ 30 $ 32 $ 36) halt (gosub not #t) (assign prev 37) (branch $ 37 96) ($ 0) halt (quote lambda) (assign prev 38) (gosub list $ 38) (assign prev 39) (gosub cadr $ 0) (assign prev 40) (gosub list $ 40) (assign prev 41) (gosub nth $ 0 2) (assign prev 42) (quote halt) (assign prev 43) (gosub T $ 42 $ 43) (assign prev 44) (gosub list $ 44) (assign prev 45) (tailcall append $ 39 $ 41 $ 45) halt)))

(define substitute (assemble '((assign arg# 0 0) (assign arg# 1 1) (assign arg# 2 2) (eq? $ 2 $ 0) (assign prev 3) (branch $ 3 15) (atom? $ 2) (assign prev 4) (branch $ 4 13) (gosub partial substitute $ 0 $ 1) (assign prev 5) (tailcall map $ 5 $ 2) halt ($ 2) halt ($ 1) halt)))

(define T-cond (assemble '((assign arg# 0 0) (assign arg# 1 1) (code (assign arg# 0 0) (assign arg# 1 1) (car $ 0) (assign prev 2) (atom? $ 2) (assign prev 3) (branch $ 3 47) (car $ 0) (assign prev 4) (quote lambda) (assign prev 5) (gosub list $ 5) (assign prev 6) (quote G#49464) (assign prev 7) (gosub list $ 7) (assign prev 8) (gosub append $ 8) (assign prev 9) (gosub list $ 9) (assign prev 10) (quote branch) (assign prev 11) (gosub list $ 11) (assign prev 12) (quote G#49464) (assign prev 13) (gosub list $ 13) (assign prev 14) (gosub cadr $ 0) (assign prev 15) (env-ref cont) (assign prev 16) (gosub T $ 15 $ 16) (assign prev 17) (gosub list $ 17) (assign prev 18) (gosub list $ 1) (assign prev 19) (gosub append $ 12 $ 14 $ 18 $ 19) (assign prev 20) (gosub list $ 20) (assign prev 21) (gosub append $ 6 $ 10 $ 21) (assign prev 22) (tailcall T $ 4 $ 22) halt (quote branch) (assign prev 23) (gosub list $ 23) (assign prev 24) (car $ 0) (assign prev 25) (gosub list $ 25) (assign prev 26) (gosub cadr $ 0) (assign prev 27) (env-ref cont) (assign prev 28) (gosub T $ 27 $ 28) (assign prev 29) (gosub list $ 29) (assign prev 30) (gosub list $ 1) (assign prev 31) (tailcall append $ 24 $ 26 $ 30 $ 31) halt) (assign prev 2) (make-env $ 1 cont) (assign prev 3) (make-closure $ 2 $ 3) (assign prev 4) (gosub last $ 0) (assign prev 5) (car $ 5) (assign prev 6) (quote else) (assign prev 7) (eq? $ 6 $ 7) (assign prev 8) (branch $ 8 40) (quote ()) (assign prev 9) (gosub T $ 9 $ 1) (assign prev 10) (gosub last $ 0) (assign prev 11) (car $ 11) (assign prev 12) (quote else) (assign prev 13) (eq? $ 12 $ 13) (assign prev 14) (branch $ 14 34) (cdr $ 0) (assign prev 15) (tailcall foldr $ 4 $ 10 $ 15) halt (gosub drop-last $ 0) (assign prev 16) (cdr $ 16) (assign prev 17) (tailcall foldr $ 4 $ 10 $ 17) halt (gosub last $ 0) (assign prev 18) (gosub cadr $ 18) (assign prev 19) (gosub T $ 19 $ 1) (assign prev 20) (gosub last $ 0) (assign prev 21) (car $ 21) (assign prev 22) (quote else) (assign prev 23) (eq? $ 22 $ 23) (assign prev 24) (branch $ 24 59) (cdr $ 0) (assign prev 25) (tailcall foldr $ 4 $ 20 $ 25) halt (gosub drop-last $ 0) (assign prev 26) (cdr $ 26) (assign prev 27) (tailcall foldr $ 4 $ 20 $ 27) halt)))

(define T-func (assemble '((assign arg# 0 0) (assign arg# 1 1) (code (assign arg# 0 0) (code (assign arg# 0 0) (code (assign arg# 0 0) (assign arg# 1 1) (gosub cadr $ 0) (assign prev 2) (atom? $ 2) (assign prev 3) (branch $ 3 27) (gosub cadr $ 0) (assign prev 4) (quote lambda) (assign prev 5) (gosub list $ 5) (assign prev 6) (car $ 0) (assign prev 7) (gosub list $ 7) (assign prev 8) (gosub append $ 8) (assign prev 9) (gosub list $ 9) (assign prev 10) (gosub list $ 1) (assign prev 11) (gosub append $ 6 $ 10 $ 11) (assign prev 12) (tailcall T $ 4 $ 12) halt ($ 1) halt) (assign prev 1) (quote call-with-cont) (assign prev 2) (gosub list $ 2) (assign prev 3) (code (assign arg# 0 0) (gosub cadr $ 0) (assign prev 1) (atom? $ 1) (assign prev 2) (branch $ 2 8) (car $ 0) halt (tailcall cadr $ 0) halt) (assign prev 4) (gosub map $ 4 $ 0) (assign prev 5) (env-ref cont) (assign prev 6) (gosub list $ 6) (assign prev 7) (gosub append $ 3 $ 5 $ 7) (assign prev 8) (gosub foldr $ 1 $ 8 $ 0) (assign prev 9) (tailcall progn $ 9) halt) (assign prev 1) (make-env cont) (assign prev 2) (make-closure $ 1 $ 2) (assign prev 3) (env-ref expression) (assign prev 4) (gosub zip $ 0 $ 4) (assign prev 5) (tailcall $ 3 $ 5) halt) (assign prev 2) (make-env $ 1 cont $ 0 expression) (assign prev 3) (make-closure $ 2 $ 3) (assign prev 4) (code (assign arg# 0 0) (gensym) halt) (assign prev 5) (gosub map $ 5 $ 0) (assign prev 6) (tailcall $ 4 $ 6) halt)))

(define T (assemble '((assign arg# 0 0) (assign arg# 1 1) (atom? $ 0) (assign prev 2) (branch $ 2 1384) (car $ 0) (assign prev 3) (quote lambda) (assign prev 4) (eq? $ 3 $ 4) (assign prev 5) (gosub not $ 5) (assign prev 6) (branch $ 6 699) (branch #t 691) (gosub count $ 0) (assign prev 7) (eq? $ 7 3) (assign prev 8) (gosub not $ 8) (assign prev 9) (branch $ 9 471) (car $ 0) (assign prev 10) (quote label) (assign prev 11) (eq? $ 10 $ 11) (assign prev 12) (gosub not $ 12) (assign prev 13) (branch $ 13 251) (branch #t 186) (quote cond) (assign prev 14) (car $ 0) (assign prev 15) (eq? $ 14 $ 15) (assign prev 16) (branch $ 16 184) (gosub count $ 0) (assign prev 17) (eq? $ 17 2) (assign prev 18) (gosub not $ 18) (assign prev 19) (branch $ 19 141) (quote quote) (assign prev 20) (car $ 0) (assign prev 21) (eq? $ 20 $ 21) (assign prev 22) (gosub not $ 22) (assign prev 23) (branch $ 23 98) (branch #t 82) (quote (gensym)) (assign prev 24) (eq? $ 24 $ 0) (assign prev 25) (branch $ 25 70) (gosub count $ 0) (assign prev 26) (gosub >= $ 26 1) (assign prev 27) (branch $ 27 68) (quote ()) halt (tailcall T-func $ 0 $ 1) halt (quote call-with-cont) (assign prev 28) (gosub list $ 28) (assign prev 29) (quote gensym) (assign prev 30) (gosub list $ 30) (assign prev 31) (gosub list $ 1) (assign prev 32) (tailcall append $ 29 $ 31 $ 32) halt (gosub list $ 1) (assign prev 33) (quote quote) (assign prev 34) (gosub list $ 34) (assign prev 35) (gosub cadr $ 0) (assign prev 36) (gosub list $ 36) (assign prev 37) (gosub append $ 35 $ 37) (assign prev 38) (gosub list $ 38) (assign prev 39) (tailcall append $ 33 $ 39) halt (branch #f 125) (quote (gensym)) (assign prev 40) (eq? $ 40 $ 0) (assign prev 41) (branch $ 41 113) (gosub count $ 0) (assign prev 42) (gosub >= $ 42 1) (assign prev 43) (branch $ 43 111) (quote ()) halt (tailcall T-func $ 0 $ 1) halt (quote call-with-cont) (assign prev 44) (gosub list $ 44) (assign prev 45) (quote gensym) (assign prev 46) (gosub list $ 46) (assign prev 47) (gosub list $ 1)
		      (assign prev 48) (tailcall append $ 45 $ 47 $ 48) halt (gosub list $ 1) (assign prev 49) (quote quote) (assign prev 50) (gosub list $ 50) (assign prev 51) (gosub cadr $ 0) (assign prev 52) (gosub list $ 52) (assign prev 53) (gosub append $ 51 $ 53) (assign prev 54) (gosub list $ 54) (assign prev 55) (tailcall append $ 49 $ 55) halt (branch #f 168) (quote (gensym)) (assign prev 56) (eq? $ 56 $ 0) (assign prev 57) (branch $ 57 156) (gosub count $ 0) (assign prev 58) (gosub >= $ 58 1) (assign prev 59) (branch $ 59 154) (quote ()) halt (tailcall T-func $ 0 $ 1) halt (quote call-with-cont) (assign prev 60) (gosub list $ 60) (assign prev 61) (quote gensym) (assign prev 62) (gosub list $ 62) (assign prev 63) (gosub list $ 1) (assign prev 64) (tailcall append $ 61 $ 63 $ 64) halt (gosub list $ 1) (assign prev 65) (quote quote) (assign prev 66) (gosub list $ 66) (assign prev 67) (gosub cadr $ 0) (assign prev 68) (gosub list $ 68) (assign prev 69) (gosub append $ 67 $ 69) (assign prev 70) (gosub list $ 70) (assign prev 71) (tailcall append $ 65 $ 71) halt (tailcall T-cond $ 0 $ 1) halt (gosub nth $ 0 2) (assign prev 72) (atom? $ 72) (assign prev 73) (branch $ 73 231) (gosub nth $ 0 2) (assign prev 74) (quote lambda) (assign prev 75) (gosub list $ 75) (assign prev 76) (quote G#346788) (assign prev 77) (gosub list $ 77) (assign prev 78) (gosub append $ 78) (assign prev 79) (gosub list $ 79) (assign prev 80) (quote call-with-cont) (assign prev 81) (gosub list $ 81) (assign prev 82) (quote label) (assign prev 83) (gosub list $ 83) (assign prev 84) (gosub cadr $ 0) (assign prev 85) (gosub list $ 85) (assign prev 86) (quote G#346788) (assign prev 87) (gosub list $ 87) (assign prev 88) (gosub list $ 1) (assign prev 89) (gosub append $ 82 $ 84 $ 86 $ 88 $ 89) (assign prev 90) (gosub list $ 90) (assign prev 91) (gosub append $ 76 $ 80 $ 91) (assign prev 92) (tailcall T $ 74 $ 92) halt (quote call-with-cont) (assign prev 93) (gosub list $ 93) (assign prev 94) (quote label)
		      (assign prev 95) (gosub list $ 95) (assign prev 96) (gosub cadr $ 0) (assign prev 97) (gosub list $ 97) (assign prev 98) (gosub nth $ 0 2) (assign prev 99) (gosub list $ 99) (assign prev 100) (gosub list $ 1) (assign prev 101) (tailcall append $ 94 $ 96 $ 98 $ 100 $ 101) halt (branch #f 406) (quote cond) (assign prev 102) (car $ 0) (assign prev 103) (eq? $ 102 $ 103) (assign prev 104) (branch $ 104 404) (gosub count $ 0) (assign prev 105) (eq? $ 105 2) (assign prev 106) (gosub not $ 106) (assign prev 107) (branch $ 107 361) (quote quote) (assign prev 108) (car $ 0) (assign prev 109) (eq? $ 108 $ 109) (assign prev 110) (gosub not $ 110) (assign prev 111) (branch $ 111 318) (branch #t 302) (quote (gensym)) (assign prev 112) (eq? $ 112 $ 0) (assign prev 113) (branch $ 113 290) (gosub count $ 0) (assign prev 114) (gosub >= $ 114 1) (assign prev 115) (branch $ 115 288) (quote ()) halt (tailcall T-func $ 0 $ 1) halt (quote call-with-cont) (assign prev 116) (gosub list $ 116) (assign prev 117) (quote gensym) (assign prev 118) (gosub list $ 118) (assign prev 119) (gosub list $ 1) (assign prev 120) (tailcall append $ 117 $ 119 $ 120) halt (gosub list $ 1) (assign prev 121) (quote quote) (assign prev 122) (gosub list $ 122) (assign prev 123) (gosub cadr $ 0) (assign prev 124) (gosub list $ 124) (assign prev 125) (gosub append $ 123 $ 125) (assign prev 126) (gosub list $ 126) (assign prev 127) (tailcall append $ 121 $ 127) halt (branch #f 345) (quote (gensym)) (assign prev 128) (eq? $ 128 $ 0) (assign prev 129) (branch $ 129 333) (gosub count $ 0) (assign prev 130) (gosub >= $ 130 1) (assign prev 131) (branch $ 131 331) (quote ()) halt (tailcall T-func $ 0 $ 1) halt (quote call-with-cont) (assign prev 132) (gosub list $ 132) (assign prev 133) (quote gensym) (assign prev 134) (gosub list $ 134) (assign prev 135) (gosub list $ 1) (assign prev 136) (tailcall append $ 133 $ 135 $ 136) halt (gosub list $ 1) (assign prev 137) (quote quote) (assign prev 138) (gosub list $ 138)
		      (assign prev 139) (gosub cadr $ 0) (assign prev 140) (gosub list $ 140) (assign prev 141) (gosub append $ 139 $ 141) (assign prev 142) (gosub list $ 142) (assign prev 143) (tailcall append $ 137 $ 143) halt (branch #f 388) (quote (gensym)) (assign prev 144) (eq? $ 144 $ 0) (assign prev 145) (branch $ 145 376) (gosub count $ 0) (assign prev 146) (gosub >= $ 146 1) (assign prev 147) (branch $ 147 374) (quote ()) halt (tailcall T-func $ 0 $ 1) halt (quote call-with-cont) (assign prev 148) (gosub list $ 148) (assign prev 149) (quote gensym) (assign prev 150) (gosub list $ 150) (assign prev 151) (gosub list $ 1) (assign prev 152) (tailcall append $ 149 $ 151 $ 152) halt (gosub list $ 1) (assign prev 153) (quote quote) (assign prev 154) (gosub list $ 154) (assign prev 155) (gosub cadr $ 0) (assign prev 156) (gosub list $ 156) (assign prev 157) (gosub append $ 155 $ 157) (assign prev 158) (gosub list $ 158) (assign prev 159) (tailcall append $ 153 $ 159) halt (tailcall T-cond $ 0 $ 1) halt (gosub nth $ 0 2) (assign prev 160) (atom? $ 160) (assign prev 161) (branch $ 161 451) (gosub nth $ 0 2) (assign prev 162) (quote lambda) (assign prev 163) (gosub list $ 163) (assign prev 164) (quote G#346788) (assign prev 165) (gosub list $ 165) (assign prev 166) (gosub append $ 166) (assign prev 167) (gosub list $ 167) (assign prev 168) (quote call-with-cont) (assign prev 169) (gosub list $ 169) (assign prev 170) (quote label) (assign prev 171) (gosub list $ 171) (assign prev 172) (gosub cadr $ 0) (assign prev 173) (gosub list $ 173) (assign prev 174) (quote G#346788) (assign prev 175) (gosub list $ 175) (assign prev 176) (gosub list $ 1) (assign prev 177) (gosub append $ 170 $ 172 $ 174 $ 176 $ 177) (assign prev 178) (gosub list $ 178) (assign prev 179) (gosub append $ 164 $ 168 $ 179) (assign prev 180) (tailcall T $ 162 $ 180) halt (quote call-with-cont) (assign prev 181) (gosub list $ 181) (assign prev 182) (quote label) (assign prev 183) (gosub list $ 183) (assign prev 184)
		      (gosub cadr $ 0) (assign prev 185) (gosub list $ 185) (assign prev 186) (gosub nth $ 0 2) (assign prev 187) (gosub list $ 187) (assign prev 188) (gosub list $ 1) (assign prev 189) (tailcall append $ 182 $ 184 $ 186 $ 188 $ 189) halt (branch #f 626) (quote cond) (assign prev 190) (car $ 0) (assign prev 191) (eq? $ 190 $ 191) (assign prev 192) (branch $ 192 624) (gosub count $ 0) (assign prev 193) (eq? $ 193 2) (assign prev 194) (gosub not $ 194) (assign prev 195) (branch $ 195 581) (quote quote) (assign prev 196) (car $ 0) (assign prev 197) (eq? $ 196 $ 197) (assign prev 198) (gosub not $ 198) (assign prev 199) (branch $ 199 538) (branch #t 522) (quote (gensym)) (assign prev 200) (eq? $ 200 $ 0) (assign prev 201) (branch $ 201 510) (gosub count $ 0) (assign prev 202) (gosub >= $ 202 1) (assign prev 203) (branch $ 203 508) (quote ()) halt (tailcall T-func $ 0 $ 1) halt (quote call-with-cont) (assign prev 204) (gosub list $ 204) (assign prev 205) (quote gensym) (assign prev 206) (gosub list $ 206) (assign prev 207) (gosub list $ 1) (assign prev 208) (tailcall append $ 205 $ 207 $ 208) halt (gosub list $ 1) (assign prev 209) (quote quote) (assign prev 210) (gosub list $ 210) (assign prev 211) (gosub cadr $ 0) (assign prev 212) (gosub list $ 212) (assign prev 213) (gosub append $ 211 $ 213) (assign prev 214) (gosub list $ 214) (assign prev 215) (tailcall append $ 209 $ 215) halt (branch #f 565) (quote (gensym)) (assign prev 216) (eq? $ 216 $ 0) (assign prev 217) (branch $ 217 553) (gosub count $ 0) (assign prev 218) (gosub >= $ 218 1) (assign prev 219) (branch $ 219 551) (quote ()) halt (tailcall T-func $ 0 $ 1) halt (quote call-with-cont) (assign prev 220) (gosub list $ 220) (assign prev 221) (quote gensym) (assign prev 222) (gosub list $ 222) (assign prev 223) (gosub list $ 1) (assign prev 224) (tailcall append $ 221 $ 223 $ 224) halt (gosub list $ 1) (assign prev 225) (quote quote) (assign prev 226) (gosub list $ 226) (assign prev 227) (gosub cadr $ 0) (assign prev 228) (gosub list $ 228)
		      (assign prev 229) (gosub append $ 227 $ 229) (assign prev 230) (gosub list $ 230) (assign prev 231) (tailcall append $ 225 $ 231) halt (branch #f 608) (quote (gensym)) (assign prev 232) (eq? $ 232 $ 0) (assign prev 233) (branch $ 233 596) (gosub count $ 0) (assign prev 234) (gosub >= $ 234 1) (assign prev 235) (branch $ 235 594) (quote ()) halt (tailcall T-func $ 0 $ 1) halt (quote call-with-cont) (assign prev 236) (gosub list $ 236) (assign prev 237) (quote gensym) (assign prev 238) (gosub list $ 238) (assign prev 239) (gosub list $ 1) (assign prev 240) (tailcall append $ 237 $ 239 $ 240) halt (gosub list $ 1) (assign prev 241) (quote quote) (assign prev 242) (gosub list $ 242) (assign prev 243) (gosub cadr $ 0) (assign prev 244) (gosub list $ 244) (assign prev 245) (gosub append $ 243 $ 245) (assign prev 246) (gosub list $ 246) (assign prev 247) (tailcall append $ 241 $ 247) halt (tailcall T-cond $ 0 $ 1) halt (gosub nth $ 0 2) (assign prev 248) (atom? $ 248) (assign prev 249) (branch $ 249 671) (gosub nth $ 0 2) (assign prev 250) (quote lambda) (assign prev 251) (gosub list $ 251) (assign prev 252) (quote G#346788) (assign prev 253) (gosub list $ 253) (assign prev 254) (gosub append $ 254) (assign prev 255) (gosub list $ 255) (assign prev 256) (quote call-with-cont) (assign prev 257) (gosub list $ 257) (assign prev 258) (quote label) (assign prev 259) (gosub list $ 259) (assign prev 260) (gosub cadr $ 0) (assign prev 261) (gosub list $ 261) (assign prev 262) (quote G#346788) (assign prev 263) (gosub list $ 263) (assign prev 264) (gosub list $ 1) (assign prev 265) (gosub append $ 258 $ 260 $ 262 $ 264 $ 265) (assign prev 266) (gosub list $ 266) (assign prev 267) (gosub append $ 252 $ 256 $ 267) (assign prev 268) (tailcall T $ 250 $ 268) halt (quote call-with-cont) (assign prev 269) (gosub list $ 269) (assign prev 270) (quote label) (assign prev 271) (gosub list $ 271) (assign prev 272) (gosub cadr $ 0) (assign prev 273) (gosub list $ 273) (assign prev 274)
		      (gosub nth $ 0 2) (assign prev 275) (gosub list $ 275) (assign prev 276) (gosub list $ 1) (assign prev 277) (tailcall append $ 270 $ 272 $ 274 $ 276 $ 277) halt (gosub list $ 1) (assign prev 278) (gosub M $ 0) (assign prev 279) (gosub list $ 279) (assign prev 280) (tailcall append $ 278 $ 280) halt (branch #f 1376) (gosub count $ 0) (assign prev 281) (eq? $ 281 3) (assign prev 282) (gosub not $ 282) (assign prev 283) (branch $ 283 1156) (car $ 0) (assign prev 284) (quote label) (assign prev 285) (eq? $ 284 $ 285) (assign prev 286) (gosub not $ 286) (assign prev 287) (branch $ 287 936) (branch #t 871) (quote cond) (assign prev 288) (car $ 0) (assign prev 289) (eq? $ 288 $ 289) (assign prev 290) (branch $ 290 869) (gosub count $ 0) (assign prev 291) (eq? $ 291 2) (assign prev 292) (gosub not $ 292) (assign prev 293) (branch $ 293 826) (quote quote) (assign prev 294) (car $ 0) (assign prev 295) (eq? $ 294 $ 295) (assign prev 296) (gosub not $ 296) (assign prev 297) (branch $ 297 783) (branch #t 767) (quote (gensym)) (assign prev 298) (eq? $ 298 $ 0) (assign prev 299) (branch $ 299 755) (gosub count $ 0) (assign prev 300) (gosub >= $ 300 1) (assign prev 301) (branch $ 301 753) (quote ()) halt (tailcall T-func $ 0 $ 1) halt (quote call-with-cont) (assign prev 302) (gosub list $ 302) (assign prev 303) (quote gensym) (assign prev 304) (gosub list $ 304) (assign prev 305) (gosub list $ 1) (assign prev 306) (tailcall append $ 303 $ 305 $ 306) halt (gosub list $ 1) (assign prev 307) (quote quote) (assign prev 308) (gosub list $ 308) (assign prev 309) (gosub cadr $ 0) (assign prev 310) (gosub list $ 310) (assign prev 311) (gosub append $ 309 $ 311) (assign prev 312) (gosub list $ 312) (assign prev 313) (tailcall append $ 307 $ 313) halt (branch #f 810) (quote (gensym)) (assign prev 314) (eq? $ 314 $ 0) (assign prev 315) (branch $ 315 798) (gosub count $ 0) (assign prev 316) (gosub >= $ 316 1) (assign prev 317) (branch $ 317 796) (quote ()) halt (tailcall T-func $ 0 $ 1)
		      halt (quote call-with-cont) (assign prev 318) (gosub list $ 318) (assign prev 319) (quote gensym) (assign prev 320) (gosub list $ 320) (assign prev 321) (gosub list $ 1) (assign prev 322) (tailcall append $ 319 $ 321 $ 322) halt (gosub list $ 1) (assign prev 323) (quote quote) (assign prev 324) (gosub list $ 324) (assign prev 325) (gosub cadr $ 0) (assign prev 326) (gosub list $ 326) (assign prev 327) (gosub append $ 325 $ 327) (assign prev 328) (gosub list $ 328) (assign prev 329) (tailcall append $ 323 $ 329) halt (branch #f 853) (quote (gensym)) (assign prev 330) (eq? $ 330 $ 0) (assign prev 331) (branch $ 331 841) (gosub count $ 0) (assign prev 332) (gosub >= $ 332 1) (assign prev 333) (branch $ 333 839) (quote ()) halt (tailcall T-func $ 0 $ 1) halt (quote call-with-cont) (assign prev 334) (gosub list $ 334) (assign prev 335) (quote gensym) (assign prev 336) (gosub list $ 336) (assign prev 337) (gosub list $ 1) (assign prev 338) (tailcall append $ 335 $ 337 $ 338) halt (gosub list $ 1) (assign prev 339) (quote quote) (assign prev 340) (gosub list $ 340) (assign prev 341) (gosub cadr $ 0) (assign prev 342) (gosub list $ 342) (assign prev 343) (gosub append $ 341 $ 343) (assign prev 344) (gosub list $ 344) (assign prev 345) (tailcall append $ 339 $ 345) halt (tailcall T-cond $ 0 $ 1) halt (gosub nth $ 0 2) (assign prev 346) (atom? $ 346) (assign prev 347) (branch $ 347 916) (gosub nth $ 0 2) (assign prev 348) (quote lambda) (assign prev 349) (gosub list $ 349) (assign prev 350) (quote G#346788) (assign prev 351) (gosub list $ 351) (assign prev 352) (gosub append $ 352) (assign prev 353) (gosub list $ 353) (assign prev 354) (quote call-with-cont) (assign prev 355) (gosub list $ 355) (assign prev 356) (quote label) (assign prev 357) (gosub list $ 357) (assign prev 358) (gosub cadr $ 0) (assign prev 359) (gosub list $ 359) (assign prev 360) (quote G#346788) (assign prev 361) (gosub list $ 361) (assign prev 362) (gosub list $ 1) (assign prev 363)
		      (gosub append $ 356 $ 358 $ 360 $ 362 $ 363) (assign prev 364) (gosub list $ 364) (assign prev 365) (gosub append $ 350 $ 354 $ 365) (assign prev 366) (tailcall T $ 348 $ 366) halt (quote call-with-cont) (assign prev 367) (gosub list $ 367) (assign prev 368) (quote label) (assign prev 369) (gosub list $ 369) (assign prev 370) (gosub cadr $ 0) (assign prev 371) (gosub list $ 371) (assign prev 372) (gosub nth $ 0 2) (assign prev 373) (gosub list $ 373) (assign prev 374) (gosub list $ 1) (assign prev 375) (tailcall append $ 368 $ 370 $ 372 $ 374 $ 375) halt (branch #f 1091) (quote cond) (assign prev 376) (car $ 0) (assign prev 377) (eq? $ 376 $ 377) (assign prev 378) (branch $ 378 1089) (gosub count $ 0) (assign prev 379) (eq? $ 379 2) (assign prev 380) (gosub not $ 380) (assign prev 381) (branch $ 381 1046) (quote quote) (assign prev 382) (car $ 0) (assign prev 383) (eq? $ 382 $ 383) (assign prev 384) (gosub not $ 384) (assign prev 385) (branch $ 385 1003) (branch #t 987) (quote (gensym)) (assign prev 386) (eq? $ 386 $ 0) (assign prev 387) (branch $ 387 975) (gosub count $ 0) (assign prev 388) (gosub >= $ 388 1) (assign prev 389) (branch $ 389 973) (quote ()) halt (tailcall T-func $ 0 $ 1) halt (quote call-with-cont) (assign prev 390) (gosub list $ 390) (assign prev 391) (quote gensym) (assign prev 392) (gosub list $ 392) (assign prev 393) (gosub list $ 1) (assign prev 394) (tailcall append $ 391 $ 393 $ 394) halt (gosub list $ 1) (assign prev 395) (quote quote) (assign prev 396) (gosub list $ 396) (assign prev 397) (gosub cadr $ 0) (assign prev 398) (gosub list $ 398) (assign prev 399) (gosub append $ 397 $ 399) (assign prev 400) (gosub list $ 400) (assign prev 401) (tailcall append $ 395 $ 401) halt (branch #f 1030) (quote (gensym)) (assign prev 402) (eq? $ 402 $ 0) (assign prev 403) (branch $ 403 1018) (gosub count $ 0) (assign prev 404) (gosub >= $ 404 1) (assign prev 405) (branch $ 405 1016) (quote ()) halt (tailcall T-func $ 0 $ 1) halt (quote call-with-cont)
		      (assign prev 406) (gosub list $ 406) (assign prev 407) (quote gensym) (assign prev 408) (gosub list $ 408) (assign prev 409) (gosub list $ 1) (assign prev 410) (tailcall append $ 407 $ 409 $ 410) halt (gosub list $ 1) (assign prev 411) (quote quote) (assign prev 412) (gosub list $ 412) (assign prev 413) (gosub cadr $ 0) (assign prev 414) (gosub list $ 414) (assign prev 415) (gosub append $ 413 $ 415) (assign prev 416) (gosub list $ 416) (assign prev 417) (tailcall append $ 411 $ 417) halt (branch #f 1073) (quote (gensym)) (assign prev 418) (eq? $ 418 $ 0) (assign prev 419) (branch $ 419 1061) (gosub count $ 0) (assign prev 420) (gosub >= $ 420 1) (assign prev 421) (branch $ 421 1059) (quote ()) halt (tailcall T-func $ 0 $ 1) halt (quote call-with-cont) (assign prev 422) (gosub list $ 422) (assign prev 423) (quote gensym) (assign prev 424) (gosub list $ 424) (assign prev 425) (gosub list $ 1) (assign prev 426) (tailcall append $ 423 $ 425 $ 426) halt (gosub list $ 1) (assign prev 427) (quote quote) (assign prev 428) (gosub list $ 428) (assign prev 429) (gosub cadr $ 0) (assign prev 430) (gosub list $ 430) (assign prev 431) (gosub append $ 429 $ 431) (assign prev 432) (gosub list $ 432) (assign prev 433) (tailcall append $ 427 $ 433) halt (tailcall T-cond $ 0 $ 1) halt (gosub nth $ 0 2) (assign prev 434) (atom? $ 434) (assign prev 435) (branch $ 435 1136) (gosub nth $ 0 2) (assign prev 436) (quote lambda) (assign prev 437) (gosub list $ 437) (assign prev 438) (quote G#346788) (assign prev 439) (gosub list $ 439) (assign prev 440) (gosub append $ 440) (assign prev 441) (gosub list $ 441) (assign prev 442) (quote call-with-cont) (assign prev 443) (gosub list $ 443) (assign prev 444) (quote label) (assign prev 445) (gosub list $ 445) (assign prev 446) (gosub cadr $ 0) (assign prev 447) (gosub list $ 447) (assign prev 448) (quote G#346788) (assign prev 449) (gosub list $ 449) (assign prev 450) (gosub list $ 1) (assign prev 451) (gosub append $ 444 $ 446 $ 448 $ 450 $ 451) (assign prev 452) (gosub list $ 452)
		      (assign prev 453) (gosub append $ 438 $ 442 $ 453) (assign prev 454) (tailcall T $ 436 $ 454) halt (quote call-with-cont) (assign prev 455) (gosub list $ 455) (assign prev 456) (quote label) (assign prev 457) (gosub list $ 457) (assign prev 458) (gosub cadr $ 0) (assign prev 459) (gosub list $ 459) (assign prev 460) (gosub nth $ 0 2) (assign prev 461) (gosub list $ 461) (assign prev 462) (gosub list $ 1) (assign prev 463) (tailcall append $ 456 $ 458 $ 460 $ 462 $ 463) halt (branch #f 1311) (quote cond) (assign prev 464) (car $ 0) (assign prev 465) (eq? $ 464 $ 465) (assign prev 466) (branch $ 466 1309) (gosub count $ 0) (assign prev 467) (eq? $ 467 2) (assign prev 468) (gosub not $ 468) (assign prev 469) (branch $ 469 1266) (quote quote) (assign prev 470) (car $ 0) (assign prev 471) (eq? $ 470 $ 471) (assign prev 472) (gosub not $ 472) (assign prev 473) (branch $ 473 1223) (branch #t 1207) (quote (gensym)) (assign prev 474) (eq? $ 474 $ 0) (assign prev 475) (branch $ 475 1195) (gosub count $ 0) (assign prev 476) (gosub >= $ 476 1) (assign prev 477) (branch $ 477 1193) (quote ()) halt (tailcall T-func $ 0 $ 1) halt (quote call-with-cont) (assign prev 478) (gosub list $ 478) (assign prev 479) (quote gensym) (assign prev 480) (gosub list $ 480) (assign prev 481) (gosub list $ 1) (assign prev 482) (tailcall append $ 479 $ 481 $ 482) halt (gosub list $ 1) (assign prev 483) (quote quote) (assign prev 484) (gosub list $ 484) (assign prev 485) (gosub cadr $ 0) (assign prev 486) (gosub list $ 486) (assign prev 487) (gosub append $ 485 $ 487) (assign prev 488) (gosub list $ 488) (assign prev 489) (tailcall append $ 483 $ 489) halt (branch #f 1250) (quote (gensym)) (assign prev 490) (eq? $ 490 $ 0) (assign prev 491) (branch $ 491 1238) (gosub count $ 0) (assign prev 492) (gosub >= $ 492 1) (assign prev 493) (branch $ 493 1236) (quote ()) halt (tailcall T-func $ 0 $ 1) halt (quote call-with-cont) (assign prev 494) (gosub list $ 494) (assign prev 495) (quote gensym)
		      (assign prev 496) (gosub list $ 496) (assign prev 497) (gosub list $ 1) (assign prev 498) (tailcall append $ 495 $ 497 $ 498) halt (gosub list $ 1) (assign prev 499) (quote quote) (assign prev 500) (gosub list $ 500) (assign prev 501) (gosub cadr $ 0) (assign prev 502) (gosub list $ 502) (assign prev 503) (gosub append $ 501 $ 503) (assign prev 504) (gosub list $ 504) (assign prev 505) (tailcall append $ 499 $ 505) halt (branch #f 1293) (quote (gensym)) (assign prev 506) (eq? $ 506 $ 0) (assign prev 507) (branch $ 507 1281) (gosub count $ 0) (assign prev 508) (gosub >= $ 508 1) (assign prev 509) (branch $ 509 1279) (quote ()) halt (tailcall T-func $ 0 $ 1) halt (quote call-with-cont) (assign prev 510) (gosub list $ 510) (assign prev 511) (quote gensym) (assign prev 512) (gosub list $ 512) (assign prev 513) (gosub list $ 1) (assign prev 514) (tailcall append $ 511 $ 513 $ 514) halt (gosub list $ 1) (assign prev 515) (quote quote) (assign prev 516) (gosub list $ 516) (assign prev 517) (gosub cadr $ 0) (assign prev 518) (gosub list $ 518) (assign prev 519) (gosub append $ 517 $ 519) (assign prev 520) (gosub list $ 520) (assign prev 521) (tailcall append $ 515 $ 521) halt (tailcall T-cond $ 0 $ 1) halt (gosub nth $ 0 2) (assign prev 522) (atom? $ 522) (assign prev 523) (branch $ 523 1356) (gosub nth $ 0 2) (assign prev 524) (quote lambda) (assign prev 525) (gosub list $ 525) (assign prev 526) (quote G#346788) (assign prev 527) (gosub list $ 527) (assign prev 528) (gosub append $ 528) (assign prev 529) (gosub list $ 529) (assign prev 530) (quote call-with-cont) (assign prev 531) (gosub list $ 531) (assign prev 532) (quote label) (assign prev 533) (gosub list $ 533) (assign prev 534) (gosub cadr $ 0) (assign prev 535) (gosub list $ 535) (assign prev 536) (quote G#346788) (assign prev 537) (gosub list $ 537) (assign prev 538) (gosub list $ 1) (assign prev 539) (gosub append $ 532 $ 534 $ 536 $ 538 $ 539) (assign prev 540) (gosub list $ 540) (assign prev 541)
		      (gosub append $ 526 $ 530 $ 541) (assign prev 542) (tailcall T $ 524 $ 542) halt (quote call-with-cont) (assign prev 543) (gosub list $ 543) (assign prev 544) (quote label) (assign prev 545) (gosub list $ 545) (assign prev 546) (gosub cadr $ 0) (assign prev 547) (gosub list $ 547) (assign prev 548) (gosub nth $ 0 2) (assign prev 549) (gosub list $ 549) (assign prev 550) (gosub list $ 1) (assign prev 551) (tailcall append $ 544 $ 546 $ 548 $ 550 $ 551) halt (gosub list $ 1) (assign prev 552) (gosub M $ 0) (assign prev 553) (gosub list $ 553) (assign prev 554) (tailcall append $ 552 $ 554) halt (atom? $ 1) (assign prev 555) (branch $ 555 1395) (gosub cadr $ 1) (assign prev 556) (car $ 556) (assign prev 557) (gosub nth $ 1 2) (assign prev 558) (tailcall substitute $ 557 $ 0 $ 558) halt (gosub list $ 1) (assign prev 559) (gosub list $ 0) (assign prev 560) (tailcall append $ 559 $ 560) halt)))

(define unfold-lambda-call (assemble '((assign arg# 0 0) (gosub cadr $ 0) (assign prev 1) (gosub unfold $ 1) (assign prev 2) (gosub list $ 2) (assign prev 3) (code (assign arg# 0 0) (quote assign) (assign prev 1) (gosub list $ 1) (assign prev 2) (gosub list $ 0) (assign prev 3) (tailcall append $ 2 $ 3) halt) (assign prev 4) (car $ 0) (assign prev 5) (gosub cadr $ 5) (assign prev 6) (gosub map $ 4 $ 6) (assign prev 7) (car $ 0) (assign prev 8) (gosub nth $ 8 2) (assign prev 9) (gosub unfold $ 9) (assign prev 10) (tailcall append $ 3 $ 7 $ 10) halt)))

;; unfold

;; fix-assignments

(define scan (assemble '((assign arg# 0 0) (assign arg# 1 1) (assign arg# 2 2) (code (assign arg# 0 0) (assign arg# 1 1) (env-ref f) (assign prev 2) (car $ 0) (assign prev 3) (gosub $ 2 $ 3 $ 1) (assign prev 4) (cons $ 4 $ 0) halt) (assign prev 3) (make-env $ 0 f) (assign prev 4) (make-closure $ 3 $ 4) (assign prev 5) (gosub list $ 1) (assign prev 6) (gosub foldl $ 5 $ 6 $ 2) (assign prev 7) (tailcall reverse $ 7) halt)))

;; fix branches

(define add-tailcalls (assemble '((assign arg# 0 0) (code (assign arg# 0 0) (assign arg# 1 1) (quote ()) (assign prev 2) (eq? $ 1 $ 2) (assign prev 3) (branch $ 3 116) (car $ 1) (assign prev 4) (quote halt) (assign prev 5) (eq? $ 4 $ 5) (assign prev 6) (gosub not $ 6) (assign prev 7) (branch $ 7 66) (branch #f 64) (gosub list? $ 0) (assign prev 8) (gosub not $ 8) (assign prev 9) (branch $ 9 53) (car $ 0) (assign prev 10) (quote gosub) (assign prev 11) (eq? $ 10 $ 11) (assign prev 12) (gosub not $ 12) (assign prev 13) (branch $ 13 42) (branch #t 34) (cons $ 0 $ 1) halt (quote tailcall) (assign prev 14) (cdr $ 0) (assign prev 15) (cons $ 14 $ 15) (assign prev 16) (cons $ 16 $ 1) halt (branch #f 45) (cons $ 0 $ 1) halt (quote tailcall) (assign prev 17) (cdr $ 0) (assign prev 18) (cons $ 17 $ 18) (assign prev 19) (cons $ 19 $ 1) halt (branch #f 56) (cons $ 0 $ 1) halt (quote tailcall) (assign prev 20) (cdr $ 0) (assign prev 21) (cons $ 20 $ 21) (assign prev 22) (cons $ 22 $ 1) halt (cons $ 0 $ 1) halt (branch #t 114) (gosub list? $ 0) (assign prev 23) (gosub not $ 23) (assign prev 24) (branch $ 24 103) (car $ 0) (assign prev 25) (quote gosub) (assign prev 26) (eq? $ 25 $ 26) (assign prev 27) (gosub not $ 27) (assign prev 28) (branch $ 28 92) (branch #t 84) (cons $ 0 $ 1) halt (quote tailcall) (assign prev 29) (cdr $ 0) (assign prev 30) (cons $ 29 $ 30) (assign prev 31) (cons $ 31 $ 1) halt (branch #f 95) (cons $ 0 $ 1) halt (quote tailcall) (assign prev 32) (cdr $ 0) (assign prev 33) (cons $ 32 $ 33) (assign prev 34) (cons $ 34 $ 1) halt (branch #f 106) (cons $ 0 $ 1) halt (quote tailcall) (assign prev 35) (cdr $ 0) (assign prev 36) (cons $ 35 $ 36) (assign prev 37) (cons $ 37 $ 1) halt (cons $ 0 $ 1) halt (branch #t 164) (gosub list? $ 0) (assign prev 38) (gosub not $ 38) (assign prev 39) (branch $ 39 153) (car $ 0) (assign prev 40) (quote gosub) (assign prev 41) (eq? $ 40 $ 41) (assign prev 42) (gosub not $ 42) (assign prev 43) (branch $ 43 142) (branch #t 134) (cons $ 0 $ 1) halt (quote tailcall) (assign prev 44) (cdr $ 0) (assign prev 45) (cons $ 44 $ 45) (assign prev 46) (cons $ 46 $ 1) halt (branch #f 145) (cons $ 0 $ 1) halt (quote tailcall) (assign prev 47) (cdr $ 0) (assign prev 48) (cons $ 47 $ 48) (assign prev 49) (cons $ 49 $ 1) halt (branch #f 156) (cons $ 0 $ 1) halt (quote tailcall) (assign prev 50) (cdr $ 0) (assign prev 51) (cons $ 50 $ 51) (assign prev 52) (cons $ 52 $ 1) halt (cons $ 0 $ 1) halt) (assign prev 1) (quote ()) (assign prev 2) (tailcall foldr $ 1 $ 2 $ 0) halt)))

(define get-immediate-lambdas (assemble '((assign arg# 0 0) (gosub list? $ 0) (assign prev 1) (branch $ 1 6) (quote ()) halt (car $ 0) (assign prev 2) (quote lambda) (assign prev 3) (eq? $ 2 $ 3) (assign prev 4) (branch $ 4 15) (tailcall mapcat get-immediate-lambdas $ 0) halt (tailcall list $ 0) halt)))

;; mark-var-args

(define optimize (assemble '((assign arg# 0 0) (code (assign arg# 0 0) (atom? $ 0) (assign prev 1) (branch $ 1 23) (car $ 0) (assign prev 2) (quote code) (assign prev 3) (eq? $ 2 $ 3) (assign prev 4) (branch $ 4 13) ($ 0) halt (quote code) (assign prev 5) (gosub list $ 5) (assign prev 6) (cdr $ 0) (assign prev 7) (gosub optimize $ 7) (assign prev 8) (tailcall append $ 6 $ 8) halt ($ 0) halt) (assign prev 1) (gosub fix-assignments $ 0) (assign prev 2) (gosub fix-branches $ 2) (assign prev 3) (gosub add-gosubs $ 3) (assign prev 4) (gosub add-tailcalls $ 4) (assign prev 5) (tailcall map $ 1 $ 5) halt)))

(define to-assembly (assemble '((assign arg# 0 0) (gosub macroexpand-all $ 0) (assign prev 1) (gosub protect-var-args $ 1) (assign prev 2) (quote ()) (assign prev 3) (gosub convert-closures $ 2 $ 3) (assign prev 4) (gosub M $ 4) (assign prev 5) (gosub unfold $ 5) (assign prev 6) (gosub optimize $ 6) (assign prev 7) (tailcall mark-var-args $ 0 $ 7) halt)))

(define compile (assemble '((assign arg# 0 0) (gosub to-assembly $ 0) (assign prev 1) (assemble $ 1) halt)))


