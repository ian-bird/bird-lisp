(define list (assemble '((var-arg) (assign arg# 0 0) ($ 0) halt)))

(define count (assemble '((assign arg# 0 0) (code (assign arg# 0 0) (assign arg# 1 1) (quote ()) (assign prev 2) (eq? $ 0 $ 2) (assign prev 3) (branch $ 3 15) (env-ref count-tco) (assign prev 4) (cdr $ 0) (assign prev 5) (+ $ 1 1) (assign prev 6) (tailcall $ 4 $ 5 $ 6) halt ($ 1) halt) (assign prev 1) (make-env count-tco) (assign prev 2) (make-closure $ 1 $ 2) (assign prev 3) (label count-tco $ 3) (assign prev 4) (gosub count-tco $ 0 0) (assign prev 5) (tailcall progn $ 4 $ 5) halt)))

(define foldl (assemble '((assign arg# 0 0) (assign arg# 1 1) (assign arg# 2 2) (quote ()) (assign prev 3) (eq? $ 2 $ 3) (assign prev 4) (branch $ 4 16) (car $ 2) (assign prev 5) (gosub $ 0 $ 1 $ 5) (assign prev 6) (cdr $ 2) (assign prev 7) (tailcall foldl $ 0 $ 6 $ 7) halt ($ 1) halt)))

(define flip (assemble '((assign arg# 0 0) (code (assign arg# 0 0) (assign arg# 1 1) (env-ref f) (assign prev 2) (tailcall $ 2 $ 1 $ 0) halt) (assign prev 1) (make-env $ 0 f) (assign prev 2) (make-closure $ 1 $ 2) halt)))

(define reverse (assemble '((assign arg# 0 0) (code (assign arg# 0 0) (assign arg# 1 1) (cons $ 1 $ 0) halt) (assign prev 1) (quote ()) (assign prev 2) (tailcall foldl $ 1 $ 2 $ 0) halt)))

(define append2 (assemble '((assign arg# 0 0) (assign arg# 1 1) (gosub flip cons) (assign prev 2) (gosub reverse $ 0) (assign prev 3) (tailcall foldl $ 2 $ 1 $ 3) halt)))

(define foldr (assemble '((assign arg# 0 0) (assign arg# 1 1) (assign arg# 2 2) (gosub flip $ 0) (assign prev 3) (gosub reverse $ 2) (assign prev 4) (tailcall foldl $ 3 $ 1 $ 4) halt)))

(define map (assemble '((assign arg# 0 0) (assign arg# 1 1) (code (assign arg# 0 0) (assign arg# 1 1) (env-ref fn) (assign prev 2) (gosub $ 2 $ 1) (assign prev 3) (cons $ 3 $ 0) halt) (assign prev 2) (make-env $ 0 fn) (assign prev 3) (make-closure $ 2 $ 3) (assign prev 4) (quote ()) (assign prev 5) (gosub foldl $ 4 $ 5 $ 1) (assign prev 6) (tailcall reverse $ 6) halt)))

(define filter (assemble '((assign arg# 0 0) (assign arg# 1 1) (code (assign arg# 0 0) (assign arg# 1 1) (env-ref fn) (assign prev 2) (gosub $ 2 $ 0) (assign prev 3) (branch $ 3 9) ($ 1) halt (cons $ 0 $ 1) halt) (assign prev 2) (make-env $ 0 fn) (assign prev 3) (make-closure $ 2 $ 3) (assign prev 4) (quote ()) (assign prev 5) (tailcall foldr $ 4 $ 5 $ 1) halt)))

(define even? (assemble '((assign arg# 0 0) (% $ 0 2) (assign prev 1) (eq? 0 $ 1) halt)))

(define last (assemble '((assign arg# 0 0) (cdr $ 0) (assign prev 1) (quote ()) (assign prev 2) (eq? $ 1 $ 2) (assign prev 3) (branch $ 3 12) (cdr $ 0) (assign prev 4) (tailcall last $ 4) halt (car $ 0) halt)))

(define progn (assemble '((var-arg) (assign arg# 0 0) (tailcall last $ 0) halt)))

(define append (assemble '((var-arg) (assign arg# 0 0) (quote ()) (assign prev 1) (tailcall foldr append2 $ 1 $ 0) halt)))

(define identity (assemble '((assign arg# 0 0) ($ 0) halt)))

(define not (assemble '((assign arg# 0 0) (branch $ 0 4) #t halt #f halt)))

(define partial (assemble '((var-arg) (assign arg# 0 0) (code (var-arg) (assign arg# 0 0) (env-ref fn-and-args) (assign prev 1) (car $ 1) (assign prev 2) (env-ref fn-and-args) (assign prev 3) (cdr $ 3) (assign prev 4) (gosub append $ 4 $ 0) (assign prev 5) (tailcall apply $ 2 $ 5) halt) (assign prev 1) (make-env $ 0 fn-and-args) (assign prev 2) (make-closure $ 1 $ 2) halt)))

(define any? (assemble '((assign arg# 0 0) (assign arg# 1 1) (code (assign arg# 0 0) (assign arg# 1 1) (branch $ 0 12) (env-ref f) (assign prev 2) (gosub $ 2 $ 1) (assign prev 3) (branch $ 3 10) #f halt #t halt ($ 0) halt) (assign prev 2) (make-env $ 0 f) (assign prev 3) (make-closure $ 2 $ 3) (assign prev 4) (tailcall foldl $ 4 #f $ 1) halt)))

(define all? (assemble '((assign arg# 0 0) (assign arg# 1 1) (code (assign arg# 0 0) (assign arg# 1 1) (gosub not $ 0) (assign prev 2) (branch $ 2 16) (env-ref f) (assign prev 3) (gosub $ 3 $ 1) (assign prev 4) (gosub not $ 4) (assign prev 5) (branch $ 5 14) #t halt #f halt #f halt) (assign prev 2) (make-env $ 0 f) (assign prev 3) (make-closure $ 2 $ 3) (assign prev 4) (tailcall foldl $ 4 #t $ 1) halt)))

(define walk (assemble '((assign arg# 0 0) (assign arg# 1 1) (assign arg# 2 2) (gosub $ 0 $ 2) (assign prev 3) (branch $ 3 12) (gosub partial walk $ 0 $ 1) (assign prev 4) (gosub map $ 4 $ 2) (assign prev 5) (tailcall $ 1 $ 5) halt (tailcall $ 0 $ 2) halt)))

(define zip (assemble '((var-arg) (assign arg# 0 0) (code (assign arg# 0 0) (quote ()) (assign prev 1) (eq? $ 0 $ 1) halt) (assign prev 1) (gosub any? $ 1 $ 0) (assign prev 2) (branch $ 2 15) (gosub map car $ 0) (assign prev 3) (gosub map cdr $ 0) (assign prev 4) (gosub apply zip $ 4) (assign prev 5) (cons $ 3 $ 5) halt (quote ()) halt)))

(define >= (assemble '((var-arg) (assign arg# 0 0) (code (assign arg# 0 0) (> $ 0 0) (assign prev 1) (branch $ 1 11) (eq? $ 0 0) (assign prev 2) (branch $ 2 9) #f halt #t halt #t halt) (assign prev 1) (gosub partial apply -) (assign prev 2) (cdr $ 0) (assign prev 3) (gosub zip $ 0 $ 3) (assign prev 4) (gosub map $ 2 $ 4) (assign prev 5) (tailcall all? $ 1 $ 5) halt)))

(define <= (assemble '((var-arg) (assign arg# 0 0) (code (assign arg# 0 0) (> 0 $ 0) (assign prev 1) (branch $ 1 11) (eq? $ 0 0) (assign prev 2) (branch $ 2 9) #f halt #t halt #t halt) (assign prev 1) (gosub partial apply -) (assign prev 2) (cdr $ 0) (assign prev 3) (gosub zip $ 0 $ 3) (assign prev 4) (gosub map $ 2 $ 4) (assign prev 5) (tailcall all? $ 1 $ 5) halt)))

(define take-last (assemble '((assign arg# 0 0) (assign arg# 1 1) (quote ()) (assign prev 2) (eq? $ 1 $ 2) (assign prev 3) (branch $ 3 18) (gosub count $ 1) (assign prev 4) (gosub >= $ 0 $ 4) (assign prev 5) (branch $ 5 16) (cdr $ 1) (assign prev 6) (tailcall take-last $ 0 $ 6) halt ($ 1) halt (quote ()) halt)))

(define inc (assemble '((assign arg# 0 0) (+ $ 0 1) halt)))

(define dec (assemble '((assign arg# 0 0) (- $ 0 1) halt)))

(define take (assemble '((assign arg# 0 0) (assign arg# 1 1) (> $ 0 0) (assign prev 2) (gosub not $ 2) (assign prev 3) (branch $ 3 46) (quote ()) (assign prev 4) (eq? $ 1 $ 4) (assign prev 5) (gosub not $ 5) (assign prev 6) (gosub not $ 6) (assign prev 7) (branch $ 7 31) (gosub not #f) (assign prev 8) (branch $ 8 21) (quote ()) halt (car $ 1) (assign prev 9) (gosub dec $ 0) (assign prev 10) (cdr $ 1) (assign prev 11) (gosub take $ 10 $ 11) (assign prev 12) (cons $ 9 $ 12) halt (gosub not #t) (assign prev 13) (branch $ 13 36) (quote ()) halt (car $ 1) (assign prev 14) (gosub dec $ 0) (assign prev 15) (cdr $ 1) (assign prev 16) (gosub take $ 15 $ 16) (assign prev 17) (cons $ 14 $ 17) halt (gosub not #t) (assign prev 18) (branch $ 18 51) (quote ()) halt (car $ 1) (assign prev 19) (gosub dec $ 0) (assign prev 20) (cdr $ 1) (assign prev 21) (gosub take $ 20 $ 21) (assign prev 22) (cons $ 19 $ 22) halt)))

(define drop (assemble '((assign arg# 0 0) (assign arg# 1 1) (> $ 0 0) (assign prev 2) (gosub not $ 2) (assign prev 3) (branch $ 3 38) (quote ()) (assign prev 4) (eq? $ 1 $ 4) (assign prev 5) (gosub not $ 5) (assign prev 6) (gosub not $ 6) (assign prev 7) (branch $ 7 27) (gosub not #f) (assign prev 8) (branch $ 8 21) ($ 1) halt (gosub dec $ 0) (assign prev 9) (cdr $ 1) (assign prev 10) (tailcall drop $ 9 $ 10) halt (gosub not #t) (assign prev 11) (branch $ 11 32) ($ 1) halt (gosub dec $ 0) (assign prev 12) (cdr $ 1) (assign prev 13) (tailcall drop $ 12 $ 13) halt (gosub not #t) (assign prev 14) (branch $ 14 43) ($ 1) halt (gosub dec $ 0) (assign prev 15) (cdr $ 1) (assign prev 16) (tailcall drop $ 15 $ 16) halt)))

(define partition (assemble '((assign arg# 0 0) (assign arg# 1 1) (assign arg# 2 2) (gosub count $ 2) (assign prev 3) (gosub >= $ 3 $ 0) (assign prev 4) (branch $ 4 10) (quote ()) halt (gosub take $ 0 $ 2) (assign prev 5) (gosub drop $ 1 $ 2) (assign prev 6) (gosub partition $ 0 $ 1 $ 6) (assign prev 7) (cons $ 5 $ 7) halt)))

(define mapcat (assemble '((assign arg# 0 0) (assign arg# 1 1) (gosub map $ 0 $ 1) (assign prev 2) (tailcall apply append $ 2) halt)))

;; too long
(define replace-subseq-2 (assemble '((assign arg# 0 0) (assign arg# 1 1) (gosub count $ 1) (assign prev 2) (> 2 $ 2) (assign prev 3) (branch $ 3 72) (car $ 1) (assign prev 4) (cdr $ 1) (assign prev 5) (car $ 5) (assign prev 6) (gosub $ 0 $ 4 $ 6) (assign prev 7) (branch $ 7 41) (car $ 1) (assign prev 8) (car $ 1) (assign prev 9) (cdr $ 1) (assign prev 10) (car $ 10) (assign prev 11) (gosub $ 0 $ 9 $ 11) (assign prev 12) (branch $ 12 33) (cdr $ 1) (assign prev 13) (gosub replace-subseq-2 $ 0 $ 13) (assign prev 14) (cons $ 8 $ 14) halt (cdr $ 1) (assign prev 15) (cdr $ 15) (assign prev 16) (gosub replace-subseq-2 $ 0 $ 16) (assign prev 17) (cons $ 8 $ 17) halt (car $ 1) (assign prev 18) (cdr $ 1) (assign prev 19) (car $ 19) (assign prev 20) (gosub $ 0 $ 18 $ 20) (assign prev 21) (car $ 1) (assign prev 22) (cdr $ 1) (assign prev 23) (car $ 23) (assign prev 24) (gosub $ 0 $ 22 $ 24) (assign prev 25) (branch $ 25 64) (cdr $ 1) (assign prev 26) (gosub replace-subseq-2 $ 0 $ 26) (assign prev 27) (cons $ 21 $ 27) halt (cdr $ 1) (assign prev 28) (cdr $ 28) (assign prev 29) (gosub replace-subseq-2 $ 0 $ 29) (assign prev 30) (cons $ 21 $ 30) halt ($ 1) halt)))

(define subseq-post-walk-2 (assemble '((assign arg# 0 0) (assign arg# 1 1) (atom? $ 1) (assign prev 2) (branch $ 2 11) (gosub partial subseq-post-walk-2 $ 0) (assign prev 3) (gosub map $ 3 $ 1) (assign prev 4) (tailcall replace-subseq-2 $ 0 $ 4) halt ($ 1) halt)))

(define alist (assemble '((assign arg# 0 0) (gosub count $ 0) (assign prev 1) (gosub even? $ 1) (assign prev 2) (branch $ 2 8) (quote ()) halt (gosub partial apply cons) (assign prev 3) (gosub partition 2 2 $ 0) (assign prev 4) (tailcall map $ 3 $ 4) halt)))

(define get (assemble '((assign arg# 0 0) (assign arg# 1 1) (quote ()) (assign prev 2) (eq? $ 0 $ 2) (assign prev 3) (branch $ 3 22) (car $ 0) (assign prev 4) (car $ 4) (assign prev 5) (eq? $ 5 $ 1) (assign prev 6) (branch $ 6 18) (cdr $ 0) (assign prev 7) (tailcall get $ 7 $ 1) halt (car $ 0) (assign prev 8) (cdr $ 8) halt (quote ()) halt)))

(define nth (assemble '((assign arg# 0 0) (assign arg# 1 1) (gosub drop $ 1 $ 0) (assign prev 2) (car $ 2) halt)))

(define update (assemble '((assign arg# 0 0) (assign arg# 1 1) (assign arg# 2 2) (gosub get $ 0 $ 1) (assign prev 3) (gosub $ 2 $ 3) (assign prev 4) (cons $ 1 $ 4) (assign prev 5) (cons $ 5 $ 0) halt)))

(define constantly (assemble '((assign arg# 0 0) (code (assign arg# 0 0) (env-ref x) halt) (assign prev 1) (make-env $ 0 x) (assign prev 2) (make-closure $ 1 $ 2) halt)))

(define unassoc (assemble '((assign arg# 0 0) (assign arg# 1 1) (code (assign arg# 0 0) (car $ 0) (assign prev 1) (env-ref k) (assign prev 2) (eq? $ 1 $ 2) (assign prev 3) (tailcall not $ 3) halt) (assign prev 2) (make-env $ 1 k) (assign prev 3) (make-closure $ 2 $ 3) (assign prev 4) (tailcall filter $ 4 $ 0) halt)))

(define range (assemble '((assign arg# 0 0) (assign arg# 1 1) (assign arg# 2 2) (> $ 1 $ 0) (assign prev 3) (branch $ 3 8) (quote ()) halt (+ $ 0 $ 2) (assign prev 4) (gosub range $ 4 $ 1 $ 2) (assign prev 5) (cons $ 0 $ 5) halt)))

(define caar (assemble '((assign arg# 0 0) (car $ 0) (assign prev 1) (car $ 1) halt)))

(define cadr (assemble '((assign arg# 0 0) (cdr $ 0) (assign prev 1) (car $ 1) halt)))

(define cdar (assemble '((assign arg# 0 0) (car $ 0) (assign prev 1) (cdr $ 1) halt)))

(define cddr (assemble '((assign arg# 0 0) (cdr $ 0) (assign prev 1) (cdr $ 1) halt)))

(define list? (assemble '((assign arg# 0 0) (atom? $ 0) (assign prev 1) (tailcall not $ 1) halt)))

(define halt (assemble '((assign arg# 0 0) ($ 0) halt)))

(define drop-last (assemble '((assign arg# 0 0) (gosub count $ 0) (assign prev 1) (gosub dec $ 1) (assign prev 2) (tailcall take $ 2 $ 0) halt)))

(define match-head (assemble '((assign arg# 0 0) (assign arg# 1 1) (quote ()) (assign prev 2) (eq? $ 0 $ 2) (assign prev 3) (branch $ 3 60) (quote ()) (assign prev 4) (eq? $ 1 $ 4) (assign prev 5) (branch $ 5 58) (car $ 0) (assign prev 6) (gosub list? $ 6) (assign prev 7) (branch $ 7 45) (car $ 0) (assign prev 8) (quote ,) (assign prev 9) (eq? $ 8 $ 9) (assign prev 10) (branch $ 10 39) (car $ 0) (assign prev 11) (car $ 1) (assign prev 12) (eq? $ 11 $ 12) (assign prev 13) (branch $ 13 33) #f halt (cdr $ 0) (assign prev 14) (cdr $ 1) (assign prev 15) (tailcall match-head $ 14 $ 15) halt (gosub cddr $ 0) (assign prev 16) (cdr $ 1) (assign prev 17) (tailcall match-head $ 16 $ 17) halt (car $ 1) (assign prev 18) (gosub list? $ 18) (assign prev 19) (branch $ 19 52) #f halt (car $ 0) (assign prev 20) (car $ 1) (assign prev 21) (tailcall match? $ 20 $ 21) halt #f halt ($ 1) halt)))

;; too long
(define match-tail (assemble '((assign arg# 0 0) (assign arg# 1 1) (code (assign arg# 0 0) (code (assign arg# 0 0) (env-ref reversed) (assign prev 1) (gosub match-head $ 0 $ 1) (assign prev 2) (tailcall progn $ 2) halt) (assign prev 1) (make-env $ 0 reversed) (assign prev 2) (make-closure $ 1 $ 2) (assign prev 3) (code (assign arg# 0 0) (code (assign arg# 0 0) (assign arg# 1 1) (quote ()) (assign prev 2) (eq? $ 0 $ 2) (assign prev 3) (gosub not $ 3) (assign prev 4) (gosub not $ 4) (assign prev 5) (branch $ 5 64) (car $ 0) (assign prev 6) (env-ref unquote) (assign prev 7) (eq? $ 6 $ 7) (assign prev 8) (gosub not $ 8) (assign prev 9) (branch $ 9 42) (gosub not #f) (assign prev 10) (branch $ 10 34) (quote ,) (assign prev 11) (eq? $ 1 $ 11) (assign prev 12) (branch $ 12 30) (cons $ 1 $ 0) halt (env-ref unquote) (assign prev 13) (cons $ 13 $ 0) halt (quote ,) (assign prev 14) (cdr $ 0) (assign prev 15) (cons $ 1 $ 15) (assign prev 16) (cons $ 14 $ 16) halt (gosub not #t) (assign prev 17) (branch $ 17 56) (quote ,) (assign prev 18) (eq? $ 1 $ 18) (assign prev 19) (branch $ 19 52) (cons $ 1 $ 0) halt (env-ref unquote) (assign prev 20) (cons $ 20 $ 0) halt (quote ,) (assign prev 21) (cdr $ 0) (assign prev 22) (cons $ 1 $ 22) (assign prev 23) (cons $ 21 $ 23) halt (gosub not #t) (assign prev 24) (branch $ 24 78) (quote ,) (assign prev 25) (eq? $ 1 $ 25) (assign prev 26) (branch $ 26 74) (cons $ 1 $ 0) halt (env-ref unquote) (assign prev 27) (cons $ 27 $ 0) halt (quote ,) (assign prev 28) (cdr $ 0) (assign prev 29) (cons $ 1 $ 29) (assign prev 30) (cons $ 28 $ 30) halt) (assign prev 1) (make-env $ 0 unquote) (assign prev 2) (make-closure $ 1 $ 2) (assign prev 3) (quote ()) (assign prev 4) (env-ref template) (assign prev 5) (gosub foldl $ 3 $ 4 $ 5) (assign prev 6) (tailcall progn $ 6) halt) (assign prev 4) (make-env template) (assign prev 5) (make-closure $ 4 $ 5) (assign prev 6) (gensym) (assign prev 7) (gosub $ 6 $ 7) (assign prev 8) (tailcall $ 3 $ 8) halt) (assign prev 2) (make-env $ 0 template) (assign prev 3) (make-closure $ 2 $ 3) (assign prev 4) (gosub reverse $ 1) (assign prev 5) (tailcall $ 4 $ 5) halt)))

(define match-centre (assemble '((assign arg# 0 0) (assign arg# 1 1) (quote ()) (assign prev 2) (eq? $ 0 $ 2) (assign prev 3) (branch $ 3 27) (quote ()) (assign prev 4) (eq? $ 1 $ 4) (assign prev 5) (branch $ 5 25) (gosub match-head $ 0 $ 1) (assign prev 6) (eq? $ 6 #f) (assign prev 7) (gosub not $ 7) (assign prev 8) (branch $ 8 23) (cdr $ 1) (assign prev 9) (tailcall match-centre $ 0 $ 9) halt (tailcall match-head $ 0 $ 1) halt #f halt ($ 1) halt)))

(define split (assemble '((assign arg# 0 0) (assign arg# 1 1) (code (assign arg# 0 0) (assign arg# 1 1) (env-ref on) (assign prev 2) (eq? $ 0 $ 2) (assign prev 3) (branch $ 3 15) (car $ 1) (assign prev 4) (cons $ 0 $ 4) (assign prev 5) (cdr $ 1) (assign prev 6) (cons $ 5 $ 6) halt (quote ()) (assign prev 7) (cons $ 7 $ 1) halt) (assign prev 2) (make-env $ 1 on) (assign prev 3) (make-closure $ 2 $ 3) (assign prev 4) (quote (())) (assign prev 5) (tailcall foldr $ 4 $ 5 $ 0) halt)))

;; too long
(define match? (assemble '((assign arg# 0 0) (assign arg# 1 1) (atom? $ 1) (assign prev 2) (branch $ 2 27) (code (assign arg# 0 0) (code (assign arg# 0 0) (code (assign arg# 0 0) (code (assign arg# 0 0) (env-ref head-matches?) (assign prev 1) (gosub not $ 1) (assign prev 2) (branch $ 2 26) (env-ref tail-matches?) (assign prev 3) (gosub not $ 3) (assign prev 4) (branch $ 4 22) (gosub not $ 0) (assign prev 5) (branch $ 5 18) (gosub not #f) (assign prev 6) (tailcall progn $ 6) halt (gosub not #t) (assign prev 7) (tailcall progn $ 7) halt (gosub not #t) (assign prev 8) (tailcall progn $ 8) halt (gosub not #t) (assign prev 9) (tailcall progn $ 9) halt) (assign prev 1) (make-env head-matches? $ 0 tail-matches?) (assign prev 2) (make-closure $ 1 $ 2) (assign prev 3) (env-ref actual-groups) (assign prev 4) (gosub count $ 4) (assign prev 5) (> $ 5 2) (assign prev 6) (branch $ 6 16) (tailcall $ 3 #t) halt (code (assign arg# 0 0) (assign arg# 1 1) (atom? $ 0) (assign prev 2) (branch $ 2 7) (tailcall match-centre $ 1 $ 0) halt ($ 0) halt) (assign prev 7) (env-ref actual-groups) (assign prev 8) (gosub last $ 8) (assign prev 9) (env-ref actual-groups) (assign prev 10) (car $ 10) (assign prev 11) (env-ref arg) (assign prev 12) (gosub match-head $ 11 $ 12) (assign prev 13) (gosub match-tail $ 9 $ 13) (assign prev 14) (env-ref actual-groups) (assign prev 15) (cdr $ 15) (assign prev 16) (gosub drop-last $ 16) (assign prev 17) (gosub foldl $ 7 $ 14 $ 17) (assign prev 18) (tailcall $ 3 $ 18) halt) (assign prev 1) (make-env $ 0 head-matches? arg actual-groups) (assign prev 2) (make-closure $ 1 $ 2) (assign prev 3) (env-ref actual-groups) (assign prev 4) (gosub last $ 4) (assign prev 5) (quote ()) (assign prev 6) (eq? $ 5 $ 6) (assign prev 7) (branch $ 7 33) (env-ref actual-groups) (assign prev 8) (gosub last $ 8) (assign prev 9) (env-ref arg) (assign prev 10) (gosub match-tail $ 9 $ 10) (assign prev 11) (eq? $ 11 #f) (assign prev 12) (gosub not $ 12) (assign prev 13) (branch $ 13 31) (tailcall $ 3 #f) halt (tailcall $ 3 #t) halt (tailcall $ 3 #t) halt) (assign prev 1) (make-env $ 0 actual-groups arg) (assign prev 2) (make-closure $ 1 $ 2) (assign prev 3) (car $ 0) (assign prev 4) (quote ()) (assign prev 5) (eq? $ 4 $ 5) (assign prev 6) (branch $ 6 29) (car $ 0) (assign prev 7) (env-ref arg) (assign prev 8) (gosub match-head $ 7 $ 8) (assign prev 9) (eq? $ 9 #f) (assign prev 10) (gosub not $ 10) (assign prev 11) (branch $ 11 27) (tailcall $ 3 #f) halt (tailcall $ 3 #t) halt (tailcall $ 3 #t) halt) (assign prev 3) (make-env $ 1 arg) (assign prev 4) (make-closure $ 3 $ 4) (assign prev 5) (code (assign arg# 0 0) (code (assign arg# 0 0) (assign arg# 1 1) (quote ()) (assign prev 2) (eq? $ 0 $ 2) (assign prev 3) (gosub not $ 3) (assign prev 4) (gosub not $ 4) (assign prev 5) (branch $ 5 60) (env-ref splicing-unquote) (assign prev 6) (car $ 0) (assign prev 7) (eq? $ 6 $ 7) (assign prev 8) (gosub not $ 8) (assign prev 9) (branch $ 9 40) (gosub not #f) (assign prev 10) (branch $ 10 34) (quote ,@) (assign prev 11) (eq? $ 1 $ 11) (assign prev 12) (branch $ 12 30) (cons $ 1 $ 0) halt (env-ref splicing-unquote) (assign prev 13) (cons $ 13 $ 0) halt (quote ,@) (assign prev 14) (cdr $ 0) (assign prev 15) (cons $ 14 $ 15) halt (gosub not #t) (assign prev 16) (branch $ 16 54) (quote ,@) (assign prev 17) (eq? $ 1 $ 17) (assign prev 18) (branch $ 18 50) (cons $ 1 $ 0) halt (env-ref splicing-unquote) (assign prev 19) (cons $ 19 $ 0) halt (quote ,@) (assign prev 20) (cdr $ 0) (assign prev 21) (cons $ 20 $ 21) halt (gosub not #t) (assign prev 22) (branch $ 22 74) (quote ,@) (assign prev 23) (eq? $ 1 $ 23) (assign prev 24) (branch $ 24 70) (cons $ 1 $ 0) halt (env-ref splicing-unquote) (assign prev 25) (cons $ 25 $ 0) halt (quote ,@) (assign prev 26) (cdr $ 0) (assign prev 27) (cons $ 26 $ 27) halt) (assign prev 1) (make-env $ 0 splicing-unquote) (assign prev 2) (make-closure $ 1 $ 2) (assign prev 3) (quote ()) (assign prev 4) (env-ref template) (assign prev 5) (gosub foldl $ 3 $ 4 $ 5) (assign prev 6) (gosub reverse $ 6) (assign prev 7) (tailcall progn $ 7) halt) (assign prev 6) (make-env $ 0 template) (assign prev 7) (make-closure $ 6 $ 7) (assign prev 8) (gensym) (assign prev 9) (gosub $ 8 $ 9) (assign prev 10) (quote ,@) (assign prev 11) (gosub split $ 10 $ 11) (assign prev 12) (tailcall $ 5 $ 12) halt #f halt)))

(define take-while (assemble '((assign arg# 0 0) (assign arg# 1 1) (quote ()) (assign prev 2) (eq? $ 1 $ 2) (assign prev 3) (branch $ 3 22) (car $ 1) (assign prev 4) (gosub $ 0 $ 4) (assign prev 5) (branch $ 5 14) (quote ()) halt (car $ 1) (assign prev 6) (cdr $ 1) (assign prev 7) (gosub take-while $ 0 $ 7) (assign prev 8) (cons $ 6 $ 8) halt (quote ()) halt)))

;; too long
(define extract-values-from-template (assemble '((assign arg# 0 0) (quote ()) (assign prev 1) (eq? $ 0 $ 1) (assign prev 2) (branch $ 2 104) (car $ 0) (assign prev 3) (quote ,) (assign prev 4) (eq? $ 3 $ 4) (assign prev 5) (branch $ 5 76) (car $ 0) (assign prev 6) (quote ,@) (assign prev 7) (eq? $ 6 $ 7) (assign prev 8) (branch $ 8 48) (branch #f 40) (car $ 0) (assign prev 9) (gosub list? $ 9) (assign prev 10) (branch $ 10 30) (cdr $ 0) (assign prev 11) (tailcall extract-values-from-template $ 11) halt (car $ 0) (assign prev 12) (gosub extract-values-from-template $ 12) (assign prev 13) (cdr $ 0) (assign prev 14) (gosub extract-values-from-template $ 14) (assign prev 15) (tailcall append $ 13 $ 15) halt (gosub cadr $ 0) (assign prev 16) (gosub cddr $ 0) (assign prev 17) (gosub extract-values-from-template $ 17) (assign prev 18) (cons $ 16 $ 18) halt (branch #t 68) (car $ 0) (assign prev 19) (gosub list? $ 19) (assign prev 20) (branch $ 20 58) (cdr $ 0) (assign prev 21) (tailcall extract-values-from-template $ 21) halt (car $ 0) (assign prev 22) (gosub extract-values-from-template $ 22) (assign prev 23) (cdr $ 0) (assign prev 24) (gosub extract-values-from-template $ 24) (assign prev 25) (tailcall append $ 23 $ 25) halt (gosub cadr $ 0) (assign prev 26) (gosub cddr $ 0) (assign prev 27) (gosub extract-values-from-template $ 27) (assign prev 28) (cons $ 26 $ 28) halt (branch #t 96) (car $ 0) (assign prev 29) (gosub list? $ 29) (assign prev 30) (branch $ 30 86) (cdr $ 0) (assign prev 31) (tailcall extract-values-from-template $ 31) halt (car $ 0) (assign prev 32) (gosub extract-values-from-template $ 32) (assign prev 33) (cdr $ 0) (assign prev 34) (gosub extract-values-from-template $ 34) (assign prev 35) (tailcall append $ 33 $ 35) halt (gosub cadr $ 0) (assign prev 36) (gosub cddr $ 0) (assign prev 37) (gosub extract-values-from-template $ 37) (assign prev 38) (cons $ 36 $ 38) halt (quote ()) halt)))

(define none? (assemble '((assign arg# 0 0) (assign arg# 1 1) (gosub any? $ 0 $ 1) (assign prev 2) (tailcall not $ 2) halt)))

;; too long
(define extract-template-value (assemble '((assign arg# 0 0) (assign arg# 1 1) (assign arg# 2 2) (quote ()) (assign prev 3) (eq? $ 0 $ 3) (assign prev 4) (branch $ 4 137) (gosub match? $ 0 $ 2) (assign prev 5) (gosub not $ 5) (assign prev 6) (branch $ 6 135) (quote ()) (assign prev 7) (eq? $ 2 $ 7) (assign prev 8) (branch $ 8 133) (car $ 0) (assign prev 9) (quote ,) (assign prev 10) (eq? $ 9 $ 10) (assign prev 11) (branch $ 11 120) (car $ 0) (assign prev 12) (quote ,@) (assign prev 13) (eq? $ 12 $ 13) (assign prev 14) (branch $ 14 68) (car $ 0) (assign prev 15) (gosub list? $ 15) (assign prev 16) (branch $ 16 43) (cdr $ 0) (assign prev 17) (cdr $ 2) (assign prev 18) (tailcall extract-template-value $ 17 $ 1 $ 18) halt (car $ 0) (assign prev 19) (car $ 2) (assign prev 20) (gosub extract-template-value $ 19 $ 1 $ 20) (assign prev 21) (quote ()) (assign prev 22) (eq? $ 21 $ 22) (assign prev 23) (gosub not $ 23) (assign prev 24) (branch $ 24 62) (cdr $ 0) (assign prev 25) (cdr $ 2) (assign prev 26) (tailcall extract-template-value $ 25 $ 1 $ 26) halt (car $ 0) (assign prev 27) (car $ 2) (assign prev 28) (tailcall extract-template-value $ 27 $ 1 $ 28) halt (gosub cadr $ 0) (assign prev 29) (eq? $ 29 $ 1) (assign prev 30) (branch $ 30 95) (gosub cddr $ 0) (assign prev 31) (code (assign arg# 0 0) (env-ref template) (assign prev 1) (env-ref from) (assign prev 2) (gosub drop $ 0 $ 2) (assign prev 3) (tailcall match? $ 1 $ 3) halt) (assign prev 32) (make-env $ 0 template $ 2 from) (assign prev 33) (make-closure $ 32 $ 33) (assign prev 34) (gosub count $ 2) (assign prev 35) (gosub inc $ 35) (assign prev 36) (gosub range 0 $ 36 1) (assign prev 37) (gosub take-while $ 34 $ 37) (assign prev 38) (gosub last $ 38) (assign prev 39) (gosub drop $ 39 $ 2) (assign prev 40) (tailcall extract-template-value $ 31 $ 1 $ 40) halt (gosub count $ 0) (assign prev 41) (> $ 41 2) (assign prev 42) (branch $ 42 102) ($ 2) halt (code (assign arg# 0 0) (env-ref template) (assign prev 1) (env-ref from) (assign prev 2) (gosub drop $ 0 $ 2) (assign prev 3) (tailcall match? $ 1 $ 3) halt) (assign prev 43) (make-env $ 0 template $ 2 from) (assign prev 44) (make-closure $ 43 $ 44) (assign prev 45) (gosub count $ 2) (assign prev 46) (gosub inc $ 46) (assign prev 47) (gosub range 0 $ 47 1) (assign prev 48) (gosub take-while $ 45 $ 48) (assign prev 49) (gosub last $ 49) (assign prev 50) (tailcall take $ 50 $ 2) halt (gosub cadr $ 0) (assign prev 51) (eq? $ 51 $ 1) (assign prev 52) (branch $ 52 131) (gosub cddr $ 0) (assign prev 53) (cdr $ 2) (assign prev 54) (tailcall extract-template-value $ 53 $ 1 $ 54) halt (car $ 2) halt (quote ()) halt panic halt (quote ()) halt)))

(define flatten (assemble '((assign arg# 0 0) (code (assign arg# 0 0) (gosub list? $ 0) (assign prev 1) (branch $ 1 6) (tailcall list $ 0) halt (tailcall flatten $ 0) halt) (assign prev 1) (tailcall mapcat $ 1 $ 0) halt)))

(define postwalk (assemble '((assign arg# 0 0) (assign arg# 1 1) (gosub list? $ 0) (assign prev 2) (branch $ 2 7) (tailcall $ 1 $ 0) halt (code (assign arg# 0 0) (env-ref fn) (assign prev 1) (tailcall postwalk $ 0 $ 1) halt) (assign prev 3) (make-env $ 1 fn) (assign prev 4) (make-closure $ 3 $ 4) (assign prev 5) (gosub map $ 5 $ 0) (assign prev 6) (tailcall $ 1 $ 6) halt)))

(define prewalk (assemble '((assign arg# 0 0) (assign arg# 1 1) (gosub list? $ 0) (assign prev 2) (branch $ 2 7) (tailcall $ 1 $ 0) halt (code (assign arg# 0 0) (env-ref fn) (assign prev 1) (tailcall prewalk $ 0 $ 1) halt) (assign prev 3) (make-env $ 1 fn) (assign prev 4) (make-closure $ 3 $ 4) (assign prev 5) (gosub $ 1 $ 0) (assign prev 6) (tailcall map $ 5 $ 6) halt)))

(define unique (assemble '((assign arg# 0 0) (code (assign arg# 0 0) (assign arg# 1 1) (gosub partial eq? $ 0) (assign prev 2) (gosub any? $ 2 $ 1) (assign prev 3) (branch $ 3 9) (cons $ 0 $ 1) halt ($ 1) halt) (assign prev 1) (quote ()) (assign prev 2) (tailcall foldr $ 1 $ 2 $ 0) halt)))

(define add-env-ref-calls (assemble '((assign arg# 0 0) (assign arg# 1 1) (gosub list? $ 0) (assign prev 2) (branch $ 2 20) (gosub partial eq? $ 0) (assign prev 3) (gosub any? $ 3 $ 1) (assign prev 4) (branch $ 4 12) ($ 0) halt (quote env-ref) (assign prev 5) (gosub list $ 5) (assign prev 6) (gosub list $ 0) (assign prev 7) (tailcall append $ 6 $ 7) halt (car $ 0) (assign prev 8) (quote make-closure) (assign prev 9) (eq? $ 8 $ 9) (assign prev 10) (branch $ 10 56) (car $ 0) (assign prev 11) (quote quote) (assign prev 12) (eq? $ 11 $ 12) (assign prev 13) (branch $ 13 45) (branch #f 43) (code (assign arg# 0 0) (env-ref free-symbols) (assign prev 1) (tailcall add-env-ref-calls $ 0 $ 1) halt) (assign prev 14) (make-env $ 1 free-symbols) (assign prev 15) (make-closure $ 14 $ 15) (assign prev 16) (tailcall map $ 16 $ 0) halt ($ 0) halt (branch #t 54) (code (assign arg# 0 0) (env-ref free-symbols) (assign prev 1) (tailcall add-env-ref-calls $ 0 $ 1) halt) (assign prev 17) (make-env $ 1 free-symbols) (assign prev 18) (make-closure $ 17 $ 18) (assign prev 19) (tailcall map $ 19 $ 0) halt ($ 0) halt (branch #t 65) (code (assign arg# 0 0) (env-ref free-symbols) (assign prev 1) (tailcall add-env-ref-calls $ 0 $ 1) halt) (assign prev 20) (make-env $ 1 free-symbols) (assign prev 21) (make-closure $ 20 $ 21) (assign prev 22) (tailcall map $ 22 $ 0) halt ($ 0) halt)))

(define referenced-free-variables (assemble '((assign arg# 0 0) (assign arg# 1 1) (gosub list? $ 0) (assign prev 2) (gosub not $ 2) (assign prev 3) (branch $ 3 56) (car $ 0) (assign prev 4) (quote quote) (assign prev 5) (eq? $ 4 $ 5) (assign prev 6) (gosub not $ 6) (assign prev 7) (gosub not $ 7) (assign prev 8) (branch $ 8 37) (gosub not #f) (assign prev 9) (branch $ 9 27) (gosub partial eq? $ 0) (assign prev 10) (gosub filter $ 10 $ 1) (assign prev 11) (tailcall unique $ 11) halt (code (assign arg# 0 0) (env-ref free-variables) (assign prev 1) (tailcall referenced-free-variables $ 0 $ 1) halt) (assign prev 12) (make-env $ 1 free-variables) (assign prev 13) (make-closure $ 12 $ 13) (assign prev 14) (gosub mapcat $ 14 $ 0) (assign prev 15) (tailcall unique $ 15) halt (gosub not #t) (assign prev 16) (branch $ 16 46) (gosub partial eq? $ 0) (assign prev 17) (gosub filter $ 17 $ 1) (assign prev 18) (tailcall unique $ 18) halt (code (assign arg# 0 0) (env-ref free-variables) (assign prev 1) (tailcall referenced-free-variables $ 0 $ 1) halt) (assign prev 19) (make-env $ 1 free-variables) (assign prev 20) (make-closure $ 19 $ 20) (assign prev 21) (gosub mapcat $ 21 $ 0) (assign prev 22) (tailcall unique $ 22) halt (gosub not #t) (assign prev 23) (branch $ 23 65) (gosub partial eq? $ 0) (assign prev 24) (gosub filter $ 24 $ 1) (assign prev 25) (tailcall unique $ 25) halt (code (assign arg# 0 0) (env-ref free-variables) (assign prev 1) (tailcall referenced-free-variables $ 0 $ 1) halt) (assign prev 26) (make-env $ 1 free-variables) (assign prev 27) (make-closure $ 26 $ 27) (assign prev 28) (gosub mapcat $ 28 $ 0) (assign prev 29) (tailcall unique $ 29) halt)))

(define extract-labels (assemble '((assign arg# 0 0) (gosub list? $ 0) (assign prev 1) (branch $ 1 6) (quote ()) halt (car $ 0) (assign prev 2) (quote label) (assign prev 3) (eq? $ 2 $ 3) (assign prev 4) (branch $ 4 15) (tailcall mapcat extract-labels $ 0) halt (gosub cadr $ 0) (assign prev 5) (gosub list $ 5) (assign prev 6) (gosub nth $ 0 2) (assign prev 7) (gosub list? $ 7) (assign prev 8) (branch $ 8 28) (quote ()) (assign prev 9) (tailcall append $ 6 $ 9) halt (gosub nth $ 0 2) (assign prev 10) (gosub mapcat extract-labels $ 10) (assign prev 11) (tailcall append $ 6 $ 11) halt)))

(define get-env-variables (assemble '((assign arg# 0 0) (gosub cadr $ 0) (assign prev 1) (gosub nth $ 0 2) (assign prev 2) (code (assign arg# 0 0) (gosub list? $ 0) (assign prev 1) (gosub not $ 1) (assign prev 2) (branch $ 2 29) (car $ 0) (assign prev 3) (quote lambda) (assign prev 4) (eq? $ 3 $ 4) (assign prev 5) (gosub not $ 5) (assign prev 6) (branch $ 6 22) (gosub not #f) (assign prev 7) (branch $ 7 20) ($ 0) halt (quote ()) halt (gosub not #t) (assign prev 8) (branch $ 8 27) ($ 0) halt (quote ()) halt (gosub not #t) (assign prev 9) (branch $ 9 34) ($ 0) halt (quote ()) halt) (assign prev 3) (gosub prewalk $ 2 $ 3) (assign prev 4) (gosub extract-labels $ 4) (assign prev 5) (tailcall append $ 1 $ 5) halt)))

(define convert-lambda (assemble '((assign arg# 0 0) (assign arg# 1 1) (code (assign arg# 0 0) (code (assign arg# 0 0) (code (assign arg# 0 0) (code (assign arg# 0 0) (env-ref closed-vars) (assign prev 1) (gosub count $ 1) (assign prev 2) (> $ 2 0) (assign prev 3) (branch $ 3 10) (tailcall progn $ 0) halt (quote make-closure) (assign prev 4) (gosub list $ 4) (assign prev 5) (gosub list $ 0) (assign prev 6) (quote make-env) (assign prev 7) (gosub list $ 7) (assign prev 8) (env-ref closed-vars) (assign prev 9) (gosub append $ 8 $ 9) (assign prev 10) (gosub list $ 10) (assign prev 11) (gosub append $ 5 $ 6 $ 11) (assign prev 12) (tailcall progn $ 12) halt) (assign prev 1) (make-env $ 0 closed-vars) (assign prev 2) (make-closure $ 1 $ 2) (assign prev 3) (quote lambda) (assign prev 4) (gosub list $ 4) (assign prev 5) (env-ref lambda-expression) (assign prev 6) (gosub cadr $ 6) (assign prev 7) (gosub list $ 7) (assign prev 8) (env-ref body) (assign prev 9) (gosub list $ 9) (assign prev 10) (gosub append $ 5 $ 8 $ 10) (assign prev 11) (tailcall $ 3 $ 11) halt) (assign prev 1) (make-env lambda-expression $ 0 body) (assign prev 2) (make-closure $ 1 $ 2) (assign prev 3) (env-ref free-vars) (assign prev 4) (gosub referenced-free-variables $ 0 $ 4) (assign prev 5) (tailcall $ 3 $ 5) halt) (assign prev 1) (make-env lambda-expression free-vars) (assign prev 2) (make-closure $ 1 $ 2) (assign prev 3) (env-ref lambda-expression) (assign prev 4) (gosub nth $ 4 2) (assign prev 5) (env-ref free-vars) (assign prev 6) (gosub append $ 0 $ 6) (assign prev 7) (gosub convert-closures $ 5 $ 7) (assign prev 8) (env-ref free-vars) (assign prev 9) (gosub add-env-ref-calls $ 8 $ 9) (assign prev 10) (tailcall $ 3 $ 10) halt) (assign prev 2) (make-env $ 0 lambda-expression $ 1 free-vars) (assign prev 3) (make-closure $ 2 $ 3) (assign prev 4) (gosub get-env-variables $ 0) (assign prev 5) (tailcall $ 4 $ 5) halt)))

(define mark-var-arg (assemble '((assign arg# 0 0) (assign arg# 1 1) (gosub list? $ 0) (assign prev 2) (gosub not $ 2) (assign prev 3) (branch $ 3 50) (car $ 0) (assign prev 4) (quote lambda) (assign prev 5) (eq? $ 4 $ 5) (assign prev 6) (gosub not $ 6) (assign prev 7) (branch $ 7 41) (gosub cadr $ 0) (assign prev 8) (atom? $ 8) (assign prev 9) (gosub not $ 9) (assign prev 10) (branch $ 10 32) (gosub not #f) (assign prev 11) (branch $ 11 28) ($ 1) halt (quote var-arg) (assign prev 12) (cons $ 12 $ 1) halt (gosub not #t) (assign prev 13) (branch $ 13 37) ($ 1) halt (quote var-arg) (assign prev 14) (cons $ 14 $ 1) halt (gosub not #t) (assign prev 15) (branch $ 15 46) ($ 1) halt (quote var-arg) (assign prev 16) (cons $ 16 $ 1) halt (gosub not #t) (assign prev 17) (branch $ 17 55) ($ 1) halt (quote var-arg) (assign prev 18) (cons $ 18 $ 1) halt)))

(define convert-closures (assemble '((assign arg# 0 0) (assign arg# 1 1) (gosub list? $ 0) (assign prev 2) (branch $ 2 7) ($ 0) halt (car $ 0) (assign prev 3) (quote lambda) (assign prev 4) (eq? $ 3 $ 4) (assign prev 5) (branch $ 5 22) (code (assign arg# 0 0) (env-ref free-vars) (assign prev 1) (tailcall convert-closures $ 0 $ 1) halt) (assign prev 6) (make-env $ 1 free-vars) (assign prev 7) (make-closure $ 6 $ 7) (assign prev 8) (tailcall map $ 8 $ 0) halt (code (assign arg# 0 0) (gosub partial eq? $ 0) (assign prev 1) (env-ref expression) (assign prev 2) (gosub cadr $ 2) (assign prev 3) (tailcall none? $ 1 $ 3) halt) (assign prev 9) (make-env $ 0 expression) (assign prev 10) (make-closure $ 9 $ 10) (assign prev 11) (gosub filter $ 11 $ 1) (assign prev 12) (tailcall convert-lambda $ 0 $ 12) halt)))

(define protect-var-args (assemble '((assign arg# 0 0) (gosub list? $ 0) (assign prev 1) (gosub not $ 1) (assign prev 2) (branch $ 2 106) (car $ 0) (assign prev 3) (quote lambda) (assign prev 4) (eq? $ 3 $ 4) (assign prev 5) (gosub not $ 5) (assign prev 6) (branch $ 6 78) (gosub cadr $ 0) (assign prev 7) (atom? $ 7) (assign prev 8) (gosub not $ 8) (assign prev 9) (branch $ 9 50) (gosub not #f) (assign prev 10) (branch $ 10 32) (gosub list? $ 0) (assign prev 11) (branch $ 11 30) ($ 0) halt (tailcall map protect-var-args $ 0) halt (quote lambda) (assign prev 12) (gosub list $ 12) (assign prev 13) (gosub cadr $ 0) (assign prev 14) (gosub list $ 14) (assign prev 15) (gosub append $ 15) (assign prev 16) (gosub list $ 16) (assign prev 17) (gosub cddr $ 0) (assign prev 18) (gosub map protect-var-args $ 18) (assign prev 19) (tailcall append $ 13 $ 17 $ 19) halt (gosub not #t) (assign prev 20) (branch $ 20 60) (gosub list? $ 0) (assign prev 21) (branch $ 21 58) ($ 0) halt (tailcall map protect-var-args $ 0) halt (quote lambda) (assign prev 22) (gosub list $ 22) (assign prev 23) (gosub cadr $ 0) (assign prev 24) (gosub list $ 24) (assign prev 25) (gosub append $ 25) (assign prev 26) (gosub list $ 26) (assign prev 27) (gosub cddr $ 0) (assign prev 28) (gosub map protect-var-args $ 28) (assign prev 29) (tailcall append $ 23 $ 27 $ 29) halt (gosub not #t) (assign prev 30) (branch $ 30 88) (gosub list? $ 0) (assign prev 31) (branch $ 31 86) ($ 0) halt (tailcall map protect-var-args $ 0) halt (quote lambda) (assign prev 32) (gosub list $ 32) (assign prev 33) (gosub cadr $ 0) (assign prev 34) (gosub list $ 34) (assign prev 35) (gosub append $ 35) (assign prev 36) (gosub list $ 36) (assign prev 37) (gosub cddr $ 0) (assign prev 38) (gosub map protect-var-args $ 38) (assign prev 39) (tailcall append $ 33 $ 37 $ 39) halt (gosub not #t) (assign prev 40) (branch $ 40 116) (gosub list? $ 0) (assign prev 41) (branch $ 41 114) ($ 0) halt (tailcall map protect-var-args $ 0) halt (quote lambda) (assign prev 42) (gosub list $ 42) (assign prev 43) (gosub cadr $ 0) (assign prev 44) (gosub list $ 44) (assign prev 45) (gosub append $ 45) (assign prev 46) (gosub list $ 46) (assign prev 47) (gosub cddr $ 0) (assign prev 48) (gosub map protect-var-args $ 48) (assign prev 49) (tailcall append $ 43 $ 47 $ 49) halt)))

(define M (assemble '((assign arg# 0 0) (gosub list? $ 0) (assign prev 1) (gosub not $ 1) (assign prev 2) (branch $ 2 91) (gosub count $ 0) (assign prev 3) (eq? $ 3 3) (assign prev 4) (gosub not $ 4) (assign prev 5) (branch $ 5 68) (car $ 0) (assign prev 6) (quote lambda) (assign prev 7) (eq? $ 6 $ 7) (assign prev 8) (gosub not $ 8) (assign prev 9) (branch $ 9 45) (gosub not #f) (assign prev 10) (branch $ 10 27) ($ 0) halt (quote lambda) (assign prev 11) (gosub list $ 11) (assign prev 12) (gosub cadr $ 0) (assign prev 13) (gosub list $ 13) (assign prev 14) (gosub nth $ 0 2) (assign prev 15) (quote halt) (assign prev 16) (gosub T $ 15 $ 16) (assign prev 17) (gosub list $ 17) (assign prev 18) (tailcall append $ 12 $ 14 $ 18) halt (gosub not #t) (assign prev 19) (branch $ 19 50) ($ 0) halt (quote lambda) (assign prev 20) (gosub list $ 20) (assign prev 21) (gosub cadr $ 0) (assign prev 22) (gosub list $ 22) (assign prev 23) (gosub nth $ 0 2) (assign prev 24) (quote halt) (assign prev 25) (gosub T $ 24 $ 25) (assign prev 26) (gosub list $ 26) (assign prev 27) (tailcall append $ 21 $ 23 $ 27) halt (gosub not #t) (assign prev 28) (branch $ 28 73) ($ 0) halt (quote lambda) (assign prev 29) (gosub list $ 29) (assign prev 30) (gosub cadr $ 0) (assign prev 31) (gosub list $ 31) (assign prev 32) (gosub nth $ 0 2) (assign prev 33) (quote halt) (assign prev 34) (gosub T $ 33 $ 34) (assign prev 35) (gosub list $ 35) (assign prev 36) (tailcall append $ 30 $ 32 $ 36) halt (gosub not #t) (assign prev 37) (branch $ 37 96) ($ 0) halt (quote lambda) (assign prev 38) (gosub list $ 38) (assign prev 39) (gosub cadr $ 0) (assign prev 40) (gosub list $ 40) (assign prev 41) (gosub nth $ 0 2) (assign prev 42) (quote halt) (assign prev 43) (gosub T $ 42 $ 43) (assign prev 44) (gosub list $ 44) (assign prev 45) (tailcall append $ 39 $ 41 $ 45) halt)))

(define substitute (assemble '((assign arg# 0 0) (assign arg# 1 1) (assign arg# 2 2) (eq? $ 2 $ 0) (assign prev 3) (branch $ 3 15) (atom? $ 2) (assign prev 4) (branch $ 4 13) (gosub partial substitute $ 0 $ 1) (assign prev 5) (tailcall map $ 5 $ 2) halt ($ 2) halt ($ 1) halt)))

(define T-cond (assemble '((assign arg# 0 0) (assign arg# 1 1) (code (assign arg# 0 0) (assign arg# 1 1) (car $ 0) (assign prev 2) (atom? $ 2) (assign prev 3) (branch $ 3 17) (code (assign arg# 0 0) (env-ref pred-and-consq) (assign prev 1) (car $ 1) (assign prev 2) (quote lambda) (assign prev 3) (gosub list $ 3) (assign prev 4) (gosub list $ 0) (assign prev 5) (gosub append $ 5) (assign prev 6) (gosub list $ 6) (assign prev 7) (quote branch) (assign prev 8) (gosub list $ 8) (assign prev 9) (gosub list $ 0) (assign prev 10) (env-ref pred-and-consq) (assign prev 11) (gosub cadr $ 11) (assign prev 12) (env-ref cont) (assign prev 13) (gosub T $ 12 $ 13) (assign prev 14) (gosub list $ 14) (assign prev 15) (env-ref acc) (assign prev 16) (gosub list $ 16) (assign prev 17) (gosub append $ 9 $ 10 $ 15 $ 17) (assign prev 18) (gosub list $ 18) (assign prev 19) (gosub append $ 4 $ 7 $ 19) (assign prev 20) (gosub T $ 2 $ 20) (assign prev 21) (tailcall progn $ 21) halt) (assign prev 4) (make-env $ 0 pred-and-consq cont $ 1 acc) (assign prev 5) (make-closure $ 4 $ 5) (assign prev 6) (gensym) (assign prev 7) (tailcall $ 6 $ 7) halt (quote branch) (assign prev 8) (gosub list $ 8) (assign prev 9) (car $ 0) (assign prev 10) (gosub list $ 10) (assign prev 11) (gosub cadr $ 0) (assign prev 12) (env-ref cont) (assign prev 13) (gosub T $ 12 $ 13) (assign prev 14) (gosub list $ 14) (assign prev 15) (gosub list $ 1) (assign prev 16) (tailcall append $ 9 $ 11 $ 15 $ 16) halt) (assign prev 2) (make-env $ 1 cont) (assign prev 3) (make-closure $ 2 $ 3) (assign prev 4) (gosub last $ 0) (assign prev 5) (car $ 5) (assign prev 6) (quote else) (assign prev 7) (eq? $ 6 $ 7) (assign prev 8) (branch $ 8 40) (quote ()) (assign prev 9) (gosub T $ 9 $ 1) (assign prev 10) (gosub last $ 0) (assign prev 11) (car $ 11) (assign prev 12) (quote else) (assign prev 13) (eq? $ 12 $ 13) (assign prev 14) (branch $ 14 34) (cdr $ 0) (assign prev 15) (tailcall foldr $ 4 $ 10 $ 15) halt (gosub drop-last $ 0) (assign prev 16) (cdr $ 16) (assign prev 17) (tailcall foldr $ 4 $ 10 $ 17) halt (gosub last $ 0) (assign prev 18) (gosub cadr $ 18) (assign prev 19) (gosub T $ 19 $ 1) (assign prev 20) (gosub last $ 0) (assign prev 21) (car $ 21) (assign prev 22) (quote else) (assign prev 23) (eq? $ 22 $ 23) (assign prev 24) (branch $ 24 59) (cdr $ 0) (assign prev 25) (tailcall foldr $ 4 $ 20 $ 25) halt (gosub drop-last $ 0) (assign prev 26) (cdr $ 26) (assign prev 27) (tailcall foldr $ 4 $ 20 $ 27) halt)))

(define T-func (assemble '((assign arg# 0 0) (assign arg# 1 1) (code (assign arg# 0 0) (code (assign arg# 0 0) (code (assign arg# 0 0) (assign arg# 1 1) (gosub cadr $ 0) (assign prev 2) (atom? $ 2) (assign prev 3) (branch $ 3 27) (gosub cadr $ 0) (assign prev 4) (quote lambda) (assign prev 5) (gosub list $ 5) (assign prev 6) (car $ 0) (assign prev 7) (gosub list $ 7) (assign prev 8) (gosub append $ 8) (assign prev 9) (gosub list $ 9) (assign prev 10) (gosub list $ 1) (assign prev 11) (gosub append $ 6 $ 10 $ 11) (assign prev 12) (tailcall T $ 4 $ 12) halt ($ 1) halt) (assign prev 1) (quote call-with-cont) (assign prev 2) (gosub list $ 2) (assign prev 3) (code (assign arg# 0 0) (gosub cadr $ 0) (assign prev 1) (atom? $ 1) (assign prev 2) (branch $ 2 8) (car $ 0) halt (tailcall cadr $ 0) halt) (assign prev 4) (gosub map $ 4 $ 0) (assign prev 5) (env-ref cont) (assign prev 6) (gosub list $ 6) (assign prev 7) (gosub append $ 3 $ 5 $ 7) (assign prev 8) (gosub foldr $ 1 $ 8 $ 0) (assign prev 9) (tailcall progn $ 9) halt) (assign prev 1) (make-env cont) (assign prev 2) (make-closure $ 1 $ 2) (assign prev 3) (env-ref expression) (assign prev 4) (gosub zip $ 0 $ 4) (assign prev 5) (tailcall $ 3 $ 5) halt) (assign prev 2) (make-env $ 1 cont $ 0 expression) (assign prev 3) (make-closure $ 2 $ 3) (assign prev 4) (code (assign arg# 0 0) (gensym) halt) (assign prev 5) (gosub map $ 5 $ 0) (assign prev 6) (tailcall $ 4 $ 6) halt)))

(define T (assemble '((assign arg# 0 0) (assign arg# 1 1) (atom? $ 0) (assign prev 2) (branch $ 2 1204) (car $ 0) (assign prev 3) (quote lambda) (assign prev 4) (eq? $ 3 $ 4) (assign prev 5) (gosub not $ 5) (assign prev 6) (branch $ 6 609) (branch #t 601) (gosub count $ 0) (assign prev 7) (eq? $ 7 3) (assign prev 8) (gosub not $ 8) (assign prev 9) (branch $ 9 411) (car $ 0) (assign prev 10) (quote label) (assign prev 11) (eq? $ 10 $ 11) (assign prev 12) (gosub not $ 12) (assign prev 13) (branch $ 13 221) (branch #t 186) (quote cond) (assign prev 14) (car $ 0) (assign prev 15) (eq? $ 14 $ 15) (assign prev 16) (branch $ 16 184) (gosub count $ 0) (assign prev 17) (eq? $ 17 2) (assign prev 18) (gosub not $ 18) (assign prev 19) (branch $ 19 141) (quote quote) (assign prev 20) (car $ 0) (assign prev 21) (eq? $ 20 $ 21) (assign prev 22) (gosub not $ 22) (assign prev 23) (branch $ 23 98) (branch #t 82) (quote (gensym)) (assign prev 24) (eq? $ 24 $ 0) (assign prev 25) (branch $ 25 70) (gosub count $ 0) (assign prev 26) (gosub >= $ 26 1) (assign prev 27) (branch $ 27 68) (quote ()) halt (tailcall T-func $ 0 $ 1) halt (quote call-with-cont) (assign prev 28) (gosub list $ 28) (assign prev 29) (quote gensym) (assign prev 30) (gosub list $ 30) (assign prev 31) (gosub list $ 1) (assign prev 32) (tailcall append $ 29 $ 31 $ 32) halt (gosub list $ 1) (assign prev 33) (quote quote) (assign prev 34) (gosub list $ 34) (assign prev 35) (gosub cadr $ 0) (assign prev 36) (gosub list $ 36) (assign prev 37) (gosub append $ 35 $ 37) (assign prev 38) (gosub list $ 38) (assign prev 39) (tailcall append $ 33 $ 39) halt (branch #f 125) (quote (gensym)) (assign prev 40) (eq? $ 40 $ 0) (assign prev 41) (branch $ 41 113) (gosub count $ 0) (assign prev 42) (gosub >= $ 42 1) (assign prev 43) (branch $ 43 111) (quote ()) halt (tailcall T-func $ 0 $ 1) halt (quote call-with-cont) (assign prev 44) (gosub list $ 44) (assign prev 45) (quote gensym) (assign prev 46) (gosub list $ 46) (assign prev 47) (gosub list $ 1) (assign prev 48) (tailcall append $ 45 $ 47 $ 48) halt (gosub list $ 1) (assign prev 49) (quote quote) (assign prev 50) (gosub list $ 50) (assign prev 51) (gosub cadr $ 0) (assign prev 52) (gosub list $ 52) (assign prev 53) (gosub append $ 51 $ 53) (assign prev 54) (gosub list $ 54) (assign prev 55) (tailcall append $ 49 $ 55) halt (branch #f 168) (quote (gensym)) (assign prev 56) (eq? $ 56 $ 0) (assign prev 57) (branch $ 57 156) (gosub count $ 0) (assign prev 58) (gosub >= $ 58 1) (assign prev 59) (branch $ 59 154) (quote ()) halt (tailcall T-func $ 0 $ 1) halt (quote call-with-cont) (assign prev 60) (gosub list $ 60) (assign prev 61) (quote gensym) (assign prev 62) (gosub list $ 62) (assign prev 63) (gosub list $ 1) (assign prev 64) (tailcall append $ 61 $ 63 $ 64) halt (gosub list $ 1) (assign prev 65) (quote quote) (assign prev 66) (gosub list $ 66) (assign prev 67) (gosub cadr $ 0) (assign prev 68) (gosub list $ 68) (assign prev 69) (gosub append $ 67 $ 69) (assign prev 70) (gosub list $ 70) (assign prev 71) (tailcall append $ 65 $ 71) halt (tailcall T-cond $ 0 $ 1) halt (gosub nth $ 0 2) (assign prev 72) (atom? $ 72) (assign prev 73) (branch $ 73 201) (code (assign arg# 0 0) (env-ref expression) (assign prev 1) (gosub nth $ 1 2) (assign prev 2) (quote lambda) (assign prev 3) (gosub list $ 3) (assign prev 4) (gosub list $ 0) (assign prev 5) (gosub append $ 5) (assign prev 6) (gosub list $ 6) (assign prev 7) (quote call-with-cont) (assign prev 8) (gosub list $ 8) (assign prev 9) (quote label) (assign prev 10) (gosub list $ 10) (assign prev 11) (env-ref expression) (assign prev 12) (gosub cadr $ 12) (assign prev 13) (gosub list $ 13) (assign prev 14) (gosub list $ 0) (assign prev 15) (env-ref cont) (assign prev 16) (gosub list $ 16) (assign prev 17) (gosub append $ 9 $ 11 $ 14 $ 15 $ 17) (assign prev 18) (gosub list $ 18) (assign prev 19) (gosub append $ 4 $ 7 $ 19) (assign prev 20) (gosub T $ 2 $ 20) (assign prev 21) (tailcall progn $ 21) halt) (assign prev 74) (make-env $ 0 expression $ 1 cont) (assign prev 75) (make-closure $ 74 $ 75) (assign prev 76) (gensym) (assign prev 77) (tailcall $ 76 $ 77) halt (quote call-with-cont) (assign prev 78) (gosub list $ 78) (assign prev 79) (quote label) (assign prev 80) (gosub list $ 80) (assign prev 81) (gosub cadr $ 0) (assign prev 82) (gosub list $ 82) (assign prev 83) (gosub nth $ 0 2) (assign prev 84) (gosub list $ 84) (assign prev 85) (gosub list $ 1) (assign prev 86) (tailcall append $ 79 $ 81 $ 83 $ 85 $ 86) halt (branch #f 376) (quote cond) (assign prev 87) (car $ 0) (assign prev 88) (eq? $ 87 $ 88) (assign prev 89) (branch $ 89 374) (gosub count $ 0) (assign prev 90) (eq? $ 90 2) (assign prev 91) (gosub not $ 91) (assign prev 92) (branch $ 92 331) (quote quote) (assign prev 93) (car $ 0) (assign prev 94) (eq? $ 93 $ 94) (assign prev 95) (gosub not $ 95) (assign prev 96) (branch $ 96 288) (branch #t 272) (quote (gensym)) (assign prev 97) (eq? $ 97 $ 0) (assign prev 98) (branch $ 98 260) (gosub count $ 0) (assign prev 99) (gosub >= $ 99 1) (assign prev 100) (branch $ 100 258) (quote ()) halt (tailcall T-func $ 0 $ 1) halt (quote call-with-cont) (assign prev 101) (gosub list $ 101) (assign prev 102) (quote gensym) (assign prev 103) (gosub list $ 103) (assign prev 104) (gosub list $ 1) (assign prev 105) (tailcall append $ 102 $ 104 $ 105) halt (gosub list $ 1) (assign prev 106) (quote quote) (assign prev 107) (gosub list $ 107) (assign prev 108) (gosub cadr $ 0) (assign prev 109) (gosub list $ 109) (assign prev 110) (gosub append $ 108 $ 110) (assign prev 111) (gosub list $ 111) (assign prev 112) (tailcall append $ 106 $ 112) halt (branch #f 315) (quote (gensym)) (assign prev 113) (eq? $ 113 $ 0) (assign prev 114) (branch $ 114 303) (gosub count $ 0) (assign prev 115) (gosub >= $ 115 1) (assign prev 116) (branch $ 116 301) (quote ()) halt (tailcall T-func $ 0 $ 1) halt (quote call-with-cont) (assign prev 117) (gosub list $ 117) (assign prev 118) (quote gensym) (assign prev 119) (gosub list $ 119) (assign prev 120) (gosub list $ 1) (assign prev 121) (tailcall append $ 118 $ 120 $ 121) halt (gosub list $ 1) (assign prev 122) (quote quote) (assign prev 123) (gosub list $ 123) (assign prev 124) (gosub cadr $ 0) (assign prev 125) (gosub list $ 125) (assign prev 126) (gosub append $ 124 $ 126) (assign prev 127) (gosub list $ 127) (assign prev 128) (tailcall append $ 122 $ 128) halt (branch #f 358) (quote (gensym)) (assign prev 129) (eq? $ 129 $ 0) (assign prev 130) (branch $ 130 346) (gosub count $ 0) (assign prev 131) (gosub >= $ 131 1) (assign prev 132) (branch $ 132 344) (quote ()) halt (tailcall T-func $ 0 $ 1) halt (quote call-with-cont) (assign prev 133) (gosub list $ 133) (assign prev 134) (quote gensym) (assign prev 135) (gosub list $ 135) (assign prev 136) (gosub list $ 1) (assign prev 137) (tailcall append $ 134 $ 136 $ 137) halt (gosub list $ 1) (assign prev 138) (quote quote) (assign prev 139) (gosub list $ 139) (assign prev 140) (gosub cadr $ 0) (assign prev 141) (gosub list $ 141) (assign prev 142) (gosub append $ 140 $ 142) (assign prev 143) (gosub list $ 143) (assign prev 144) (tailcall append $ 138 $ 144) halt (tailcall T-cond $ 0 $ 1) halt (gosub nth $ 0 2) (assign prev 145) (atom? $ 145) (assign prev 146) (branch $ 146 391) (code (assign arg# 0 0) (env-ref expression) (assign prev 1) (gosub nth $ 1 2) (assign prev 2) (quote lambda) (assign prev 3) (gosub list $ 3) (assign prev 4) (gosub list $ 0) (assign prev 5) (gosub append $ 5) (assign prev 6) (gosub list $ 6) (assign prev 7) (quote call-with-cont) (assign prev 8) (gosub list $ 8) (assign prev 9) (quote label) (assign prev 10) (gosub list $ 10) (assign prev 11) (env-ref expression) (assign prev 12) (gosub cadr $ 12) (assign prev 13) (gosub list $ 13) (assign prev 14) (gosub list $ 0) (assign prev 15) (env-ref cont) (assign prev 16) (gosub list $ 16) (assign prev 17) (gosub append $ 9 $ 11 $ 14 $ 15 $ 17) (assign prev 18) (gosub list $ 18) (assign prev 19) (gosub append $ 4 $ 7 $ 19) (assign prev 20) (gosub T $ 2 $ 20) (assign prev 21) (tailcall progn $ 21) halt) (assign prev 147) (make-env $ 0 expression $ 1 cont) (assign prev 148) (make-closure $ 147 $ 148) (assign prev 149) (gensym) (assign prev 150) (tailcall $ 149 $ 150) halt (quote call-with-cont) (assign prev 151) (gosub list $ 151) (assign prev 152) (quote label) (assign prev 153) (gosub list $ 153) (assign prev 154) (gosub cadr $ 0) (assign prev 155) (gosub list $ 155) (assign prev 156) (gosub nth $ 0 2) (assign prev 157) (gosub list $ 157) (assign prev 158) (gosub list $ 1) (assign prev 159) (tailcall append $ 152 $ 154 $ 156 $ 158 $ 159) halt (branch #f 566) (quote cond) (assign prev 160) (car $ 0) (assign prev 161) (eq? $ 160 $ 161) (assign prev 162) (branch $ 162 564) (gosub count $ 0) (assign prev 163) (eq? $ 163 2) (assign prev 164) (gosub not $ 164) (assign prev 165) (branch $ 165 521) (quote quote) (assign prev 166) (car $ 0) (assign prev 167) (eq? $ 166 $ 167) (assign prev 168) (gosub not $ 168) (assign prev 169) (branch $ 169 478) (branch #t 462) (quote (gensym)) (assign prev 170) (eq? $ 170 $ 0) (assign prev 171) (branch $ 171 450) (gosub count $ 0) (assign prev 172) (gosub >= $ 172 1) (assign prev 173) (branch $ 173 448) (quote ()) halt (tailcall T-func $ 0 $ 1) halt (quote call-with-cont) (assign prev 174) (gosub list $ 174) (assign prev 175) (quote gensym) (assign prev 176) (gosub list $ 176) (assign prev 177) (gosub list $ 1) (assign prev 178) (tailcall append $ 175 $ 177 $ 178) halt (gosub list $ 1) (assign prev 179) (quote quote) (assign prev 180) (gosub list $ 180) (assign prev 181) (gosub cadr $ 0) (assign prev 182) (gosub list $ 182) (assign prev 183) (gosub append $ 181 $ 183) (assign prev 184) (gosub list $ 184) (assign prev 185) (tailcall append $ 179 $ 185) halt (branch #f 505) (quote (gensym)) (assign prev 186) (eq? $ 186 $ 0) (assign prev 187) (branch $ 187 493) (gosub count $ 0) (assign prev 188) (gosub >= $ 188 1) (assign prev 189) (branch $ 189 491) (quote ())
		      halt (tailcall T-func $ 0 $ 1) halt (quote call-with-cont) (assign prev 190) (gosub list $ 190) (assign prev 191) (quote gensym) (assign prev 192) (gosub list $ 192) (assign prev 193) (gosub list $ 1) (assign prev 194) (tailcall append $ 191 $ 193 $ 194) halt (gosub list $ 1) (assign prev 195) (quote quote) (assign prev 196) (gosub list $ 196) (assign prev 197) (gosub cadr $ 0) (assign prev 198) (gosub list $ 198) (assign prev 199) (gosub append $ 197 $ 199) (assign prev 200) (gosub list $ 200) (assign prev 201) (tailcall append $ 195 $ 201) halt (branch #f 548) (quote (gensym)) (assign prev 202) (eq? $ 202 $ 0) (assign prev 203) (branch $ 203 536) (gosub count $ 0) (assign prev 204) (gosub >= $ 204 1) (assign prev 205) (branch $ 205 534) (quote ()) halt (tailcall T-func $ 0 $ 1) halt (quote call-with-cont) (assign prev 206) (gosub list $ 206) (assign prev 207) (quote gensym) (assign prev 208) (gosub list $ 208) (assign prev 209) (gosub list $ 1) (assign prev 210) (tailcall append $ 207 $ 209 $ 210) halt (gosub list $ 1) (assign prev 211) (quote quote) (assign prev 212) (gosub list $ 212) (assign prev 213) (gosub cadr $ 0) (assign prev 214) (gosub list $ 214) (assign prev 215) (gosub append $ 213 $ 215) (assign prev 216) (gosub list $ 216) (assign prev 217) (tailcall append $ 211 $ 217) halt (tailcall T-cond $ 0 $ 1) halt (gosub nth $ 0 2) (assign prev 218) (atom? $ 218) (assign prev 219) (branch $ 219 581) (code (assign arg# 0 0) (env-ref expression) (assign prev 1) (gosub nth $ 1 2) (assign prev 2) (quote lambda) (assign prev 3) (gosub list $ 3) (assign prev 4) (gosub list $ 0) (assign prev 5) (gosub append $ 5) (assign prev 6) (gosub list $ 6) (assign prev 7) (quote call-with-cont) (assign prev 8) (gosub list $ 8) (assign prev 9) (quote label) (assign prev 10) (gosub list $ 10) (assign prev 11) (env-ref expression) (assign prev 12) (gosub cadr $ 12) (assign prev 13) (gosub list $ 13) (assign prev 14) (gosub list $ 0) (assign prev 15) (env-ref cont) (assign prev 16) (gosub list $ 16) (assign prev 17) (gosub append $ 9 $ 11 $ 14 $ 15 $ 17) (assign prev 18) (gosub list $ 18) (assign prev 19) (gosub append $ 4 $ 7 $ 19) (assign prev 20) (gosub T $ 2 $ 20) (assign prev 21) (tailcall progn $ 21) halt) (assign prev 220) (make-env $ 0 expression $ 1 cont) (assign prev 221) (make-closure $ 220 $ 221) (assign prev 222) (gensym) (assign prev 223) (tailcall $ 222 $ 223) halt (quote call-with-cont) (assign prev 224) (gosub list $ 224) (assign prev 225) (quote label) (assign prev 226) (gosub list $ 226) (assign prev 227) (gosub cadr $ 0) (assign prev 228) (gosub list $ 228) (assign prev 229) (gosub nth $ 0 2) (assign prev 230) (gosub list $ 230) (assign prev 231) (gosub list $ 1) (assign prev 232) (tailcall append $ 225 $ 227 $ 229 $ 231 $ 232) halt (gosub list $ 1) (assign prev 233) (gosub M $ 0) (assign prev 234) (gosub list $ 234) (assign prev 235) (tailcall append $ 233 $ 235) halt (branch #f 1196) (gosub count $ 0) (assign prev 236) (eq? $ 236 3) (assign prev 237) (gosub not $ 237) (assign prev 238) (branch $ 238 1006) (car $ 0) (assign prev 239) (quote label) (assign prev 240) (eq? $ 239 $ 240) (assign prev 241) (gosub not $ 241) (assign prev 242) (branch $ 242 816) (branch #t 781) (quote cond) (assign prev 243) (car $ 0) (assign prev 244) (eq? $ 243 $ 244) (assign prev 245) (branch $ 245 779) (gosub count $ 0) (assign prev 246) (eq? $ 246 2) (assign prev 247) (gosub not $ 247) (assign prev 248) (branch $ 248 736) (quote quote) (assign prev 249) (car $ 0) (assign prev 250) (eq? $ 249 $ 250) (assign prev 251) (gosub not $ 251) (assign prev 252) (branch $ 252 693) (branch #t 677) (quote (gensym)) (assign prev 253) (eq? $ 253 $ 0) (assign prev 254) (branch $ 254 665) (gosub count $ 0) (assign prev 255) (gosub >= $ 255 1) (assign prev 256) (branch $ 256 663) (quote ()) halt (tailcall T-func $ 0 $ 1) halt (quote call-with-cont) (assign prev 257) (gosub list $ 257) (assign prev 258) (quote gensym) (assign prev 259) (gosub list $ 259) (assign prev 260) (gosub list $ 1) (assign prev 261) (tailcall append $ 258 $ 260 $ 261) halt (gosub list $ 1) (assign prev 262) (quote quote) (assign prev 263) (gosub list $ 263) (assign prev 264) (gosub cadr $ 0) (assign prev 265) (gosub list $ 265) (assign prev 266) (gosub append $ 264 $ 266) (assign prev 267) (gosub list $ 267) (assign prev 268) (tailcall append $ 262 $ 268) halt (branch #f 720) (quote (gensym)) (assign prev 269) (eq? $ 269 $ 0) (assign prev 270) (branch $ 270 708) (gosub count $ 0) (assign prev 271) (gosub >= $ 271 1) (assign prev 272) (branch $ 272 706) (quote ()) halt (tailcall T-func $ 0 $ 1) halt (quote call-with-cont) (assign prev 273) (gosub list $ 273) (assign prev 274) (quote gensym) (assign prev 275) (gosub list $ 275) (assign prev 276) (gosub list $ 1) (assign prev 277) (tailcall append $ 274 $ 276 $ 277) halt (gosub list $ 1) (assign prev 278) (quote quote) (assign prev 279) (gosub list $ 279) (assign prev 280) (gosub cadr $ 0) (assign prev 281) (gosub list $ 281) (assign prev 282) (gosub append $ 280 $ 282) (assign prev 283) (gosub list $ 283) (assign prev 284) (tailcall append $ 278 $ 284) halt (branch #f 763) (quote (gensym)) (assign prev 285) (eq? $ 285 $ 0) (assign prev 286) (branch $ 286 751) (gosub count $ 0) (assign prev 287) (gosub >= $ 287 1) (assign prev 288) (branch $ 288 749) (quote ()) halt (tailcall T-func $ 0 $ 1) halt (quote call-with-cont) (assign prev 289) (gosub list $ 289) (assign prev 290) (quote gensym) (assign prev 291) (gosub list $ 291) (assign prev 292) (gosub list $ 1) (assign prev 293) (tailcall append $ 290 $ 292 $ 293) halt (gosub list $ 1) (assign prev 294) (quote quote) (assign prev 295) (gosub list $ 295) (assign prev 296) (gosub cadr $ 0) (assign prev 297) (gosub list $ 297) (assign prev 298) (gosub append $ 296 $ 298) (assign prev 299) (gosub list $ 299) (assign prev 300) (tailcall append $ 294 $ 300) halt (tailcall T-cond $ 0 $ 1) halt (gosub nth $ 0 2) (assign prev 301) (atom? $ 301) (assign prev 302) (branch $ 302 796) (code (assign arg# 0 0) (env-ref expression) (assign prev 1) (gosub nth $ 1 2) (assign prev 2) (quote lambda) (assign prev 3) (gosub list $ 3) (assign prev 4) (gosub list $ 0) (assign prev 5) (gosub append $ 5) (assign prev 6) (gosub list $ 6) (assign prev 7) (quote call-with-cont) (assign prev 8) (gosub list $ 8) (assign prev 9) (quote label) (assign prev 10) (gosub list $ 10) (assign prev 11) (env-ref expression) (assign prev 12) (gosub cadr $ 12) (assign prev 13) (gosub list $ 13) (assign prev 14) (gosub list $ 0) (assign prev 15) (env-ref cont) (assign prev 16) (gosub list $ 16) (assign prev 17) (gosub append $ 9 $ 11 $ 14 $ 15 $ 17) (assign prev 18) (gosub list $ 18) (assign prev 19) (gosub append $ 4 $ 7 $ 19) (assign prev 20) (gosub T $ 2 $ 20) (assign prev 21) (tailcall progn $ 21) halt) (assign prev 303) (make-env $ 0 expression $ 1 cont) (assign prev 304) (make-closure $ 303 $ 304) (assign prev 305) (gensym) (assign prev 306) (tailcall $ 305 $ 306) halt (quote call-with-cont) (assign prev 307) (gosub list $ 307) (assign prev 308) (quote label) (assign prev 309) (gosub list $ 309) (assign prev 310) (gosub cadr $ 0) (assign prev 311) (gosub list $ 311) (assign prev 312) (gosub nth $ 0 2) (assign prev 313) (gosub list $ 313) (assign prev 314) (gosub list $ 1) (assign prev 315) (tailcall append $ 308 $ 310 $ 312 $ 314 $ 315) halt (branch #f 971) (quote cond) (assign prev 316) (car $ 0) (assign prev 317) (eq? $ 316 $ 317) (assign prev 318) (branch $ 318 969) (gosub count $ 0) (assign prev 319) (eq? $ 319 2) (assign prev 320) (gosub not $ 320) (assign prev 321) (branch $ 321 926) (quote quote) (assign prev 322) (car $ 0) (assign prev 323) (eq? $ 322 $ 323) (assign prev 324) (gosub not $ 324) (assign prev 325) (branch $ 325 883) (branch #t 867) (quote (gensym)) (assign prev 326) (eq? $ 326 $ 0) (assign prev 327) (branch $ 327 855) (gosub count $ 0) (assign prev 328) (gosub >= $ 328 1) (assign prev 329) (branch $ 329 853) (quote ()) halt (tailcall T-func $ 0 $ 1) halt (quote call-with-cont) (assign prev 330) (gosub list $ 330) (assign prev 331) (quote gensym) (assign prev 332) (gosub list $ 332) (assign prev 333) (gosub list $ 1) (assign prev 334) (tailcall append $ 331 $ 333 $ 334) halt (gosub list $ 1) (assign prev 335) (quote quote) (assign prev 336) (gosub list $ 336) (assign prev 337) (gosub cadr $ 0) (assign prev 338) (gosub list $ 338) (assign prev 339) (gosub append $ 337 $ 339) (assign prev 340) (gosub list $ 340) (assign prev 341) (tailcall append $ 335 $ 341) halt (branch #f 910) (quote (gensym)) (assign prev 342) (eq? $ 342 $ 0) (assign prev 343) (branch $ 343 898) (gosub count $ 0) (assign prev 344) (gosub >= $ 344 1) (assign prev 345) (branch $ 345 896) (quote ()) halt (tailcall T-func $ 0 $ 1) halt (quote call-with-cont) (assign prev 346) (gosub list $ 346) (assign prev 347) (quote gensym) (assign prev 348) (gosub list $ 348) (assign prev 349) (gosub list $ 1) (assign prev 350) (tailcall append $ 347 $ 349 $ 350) halt (gosub list $ 1) (assign prev 351) (quote quote) (assign prev 352) (gosub list $ 352) (assign prev 353) (gosub cadr $ 0) (assign prev 354) (gosub list $ 354) (assign prev 355) (gosub append $ 353 $ 355) (assign prev 356) (gosub list $ 356) (assign prev 357) (tailcall append $ 351 $ 357) halt (branch #f 953) (quote (gensym)) (assign prev 358) (eq? $ 358 $ 0) (assign prev 359) (branch $ 359 941) (gosub count $ 0) (assign prev 360) (gosub >= $ 360 1) (assign prev 361) (branch $ 361 939) (quote ()) halt (tailcall T-func $ 0 $ 1) halt (quote call-with-cont) (assign prev 362) (gosub list $ 362) (assign prev 363) (quote gensym) (assign prev 364) (gosub list $ 364) (assign prev 365) (gosub list $ 1) (assign prev 366) (tailcall append $ 363 $ 365 $ 366) halt (gosub list $ 1) (assign prev 367) (quote quote) (assign prev 368) (gosub list $ 368) (assign prev 369) (gosub cadr $ 0) (assign prev 370) (gosub list $ 370) (assign prev 371) (gosub append $ 369 $ 371) (assign prev 372) (gosub list $ 372)
		      (assign prev 373) (tailcall append $ 367 $ 373) halt (tailcall T-cond $ 0 $ 1) halt (gosub nth $ 0 2) (assign prev 374) (atom? $ 374) (assign prev 375) (branch $ 375 986) (code (assign arg# 0 0) (env-ref expression) (assign prev 1) (gosub nth $ 1 2) (assign prev 2) (quote lambda) (assign prev 3) (gosub list $ 3) (assign prev 4) (gosub list $ 0) (assign prev 5) (gosub append $ 5) (assign prev 6) (gosub list $ 6) (assign prev 7) (quote call-with-cont) (assign prev 8) (gosub list $ 8) (assign prev 9) (quote label) (assign prev 10) (gosub list $ 10) (assign prev 11) (env-ref expression) (assign prev 12) (gosub cadr $ 12) (assign prev 13) (gosub list $ 13) (assign prev 14) (gosub list $ 0) (assign prev 15) (env-ref cont) (assign prev 16) (gosub list $ 16) (assign prev 17) (gosub append $ 9 $ 11 $ 14 $ 15 $ 17) (assign prev 18) (gosub list $ 18) (assign prev 19) (gosub append $ 4 $ 7 $ 19) (assign prev 20) (gosub T $ 2 $ 20) (assign prev 21) (tailcall progn $ 21) halt) (assign prev 376) (make-env $ 0 expression $ 1 cont) (assign prev 377) (make-closure $ 376 $ 377) (assign prev 378) (gensym) (assign prev 379) (tailcall $ 378 $ 379) halt (quote call-with-cont) (assign prev 380) (gosub list $ 380) (assign prev 381) (quote label) (assign prev 382) (gosub list $ 382) (assign prev 383) (gosub cadr $ 0) (assign prev 384) (gosub list $ 384) (assign prev 385) (gosub nth $ 0 2) (assign prev 386) (gosub list $ 386) (assign prev 387) (gosub list $ 1) (assign prev 388) (tailcall append $ 381 $ 383 $ 385 $ 387 $ 388) halt (branch #f 1161) (quote cond) (assign prev 389) (car $ 0) (assign prev 390) (eq? $ 389 $ 390) (assign prev 391) (branch $ 391 1159) (gosub count $ 0) (assign prev 392) (eq? $ 392 2) (assign prev 393) (gosub not $ 393) (assign prev 394) (branch $ 394 1116) (quote quote) (assign prev 395) (car $ 0) (assign prev 396) (eq? $ 395 $ 396) (assign prev 397) (gosub not $ 397) (assign prev 398) (branch $ 398 1073) (branch #t 1057) (quote (gensym)) (assign prev 399) (eq? $ 399 $ 0) (assign prev 400) (branch $ 400 1045) (gosub count $ 0) (assign prev 401) (gosub >= $ 401 1) (assign prev 402) (branch $ 402 1043) (quote ()) halt (tailcall T-func $ 0 $ 1) halt (quote call-with-cont) (assign prev 403) (gosub list $ 403) (assign prev 404) (quote gensym) (assign prev 405) (gosub list $ 405) (assign prev 406) (gosub list $ 1) (assign prev 407) (tailcall append $ 404 $ 406 $ 407) halt (gosub list $ 1) (assign prev 408) (quote quote) (assign prev 409) (gosub list $ 409) (assign prev 410) (gosub cadr $ 0) (assign prev 411) (gosub list $ 411) (assign prev 412) (gosub append $ 410 $ 412) (assign prev 413) (gosub list $ 413) (assign prev 414) (tailcall append $ 408 $ 414) halt (branch #f 1100) (quote (gensym)) (assign prev 415) (eq? $ 415 $ 0) (assign prev 416) (branch $ 416 1088) (gosub count $ 0) (assign prev 417) (gosub >= $ 417 1) (assign prev 418) (branch $ 418 1086) (quote ()) halt (tailcall T-func $ 0 $ 1) halt (quote call-with-cont) (assign prev 419) (gosub list $ 419) (assign prev 420) (quote gensym) (assign prev 421) (gosub list $ 421) (assign prev 422) (gosub list $ 1) (assign prev 423) (tailcall append $ 420 $ 422 $ 423) halt (gosub list $ 1) (assign prev 424) (quote quote) (assign prev 425) (gosub list $ 425) (assign prev 426) (gosub cadr $ 0) (assign prev 427) (gosub list $ 427) (assign prev 428) (gosub append $ 426 $ 428) (assign prev 429) (gosub list $ 429) (assign prev 430) (tailcall append $ 424 $ 430) halt (branch #f 1143) (quote (gensym)) (assign prev 431) (eq? $ 431 $ 0) (assign prev 432) (branch $ 432 1131) (gosub count $ 0) (assign prev 433) (gosub >= $ 433 1) (assign prev 434) (branch $ 434 1129) (quote ()) halt (tailcall T-func $ 0 $ 1) halt (quote call-with-cont) (assign prev 435) (gosub list $ 435) (assign prev 436) (quote gensym) (assign prev 437) (gosub list $ 437) (assign prev 438) (gosub list $ 1) (assign prev 439) (tailcall append $ 436 $ 438 $ 439) halt (gosub list $ 1) (assign prev 440) (quote quote) (assign prev 441) (gosub list $ 441) (assign prev 442) (gosub cadr $ 0) (assign prev 443) (gosub list $ 443) (assign prev 444) (gosub append $ 442 $ 444) (assign prev 445) (gosub list $ 445) (assign prev 446) (tailcall append $ 440 $ 446) halt (tailcall T-cond $ 0 $ 1) halt (gosub nth $ 0 2) (assign prev 447) (atom? $ 447) (assign prev 448) (branch $ 448 1176) (code (assign arg# 0 0) (env-ref expression) (assign prev 1) (gosub nth $ 1 2) (assign prev 2) (quote lambda) (assign prev 3) (gosub list $ 3) (assign prev 4) (gosub list $ 0) (assign prev 5) (gosub append $ 5) (assign prev 6) (gosub list $ 6) (assign prev 7) (quote call-with-cont) (assign prev 8) (gosub list $ 8) (assign prev 9) (quote label) (assign prev 10) (gosub list $ 10) (assign prev 11) (env-ref expression) (assign prev 12) (gosub cadr $ 12) (assign prev 13) (gosub list $ 13) (assign prev 14) (gosub list $ 0) (assign prev 15) (env-ref cont) (assign prev 16) (gosub list $ 16) (assign prev 17) (gosub append $ 9 $ 11 $ 14 $ 15 $ 17) (assign prev 18) (gosub list $ 18) (assign prev 19) (gosub append $ 4 $ 7 $ 19) (assign prev 20) (gosub T $ 2 $ 20) (assign prev 21) (tailcall progn $ 21) halt) (assign prev 449) (make-env $ 0 expression $ 1 cont) (assign prev 450) (make-closure $ 449 $ 450) (assign prev 451) (gensym) (assign prev 452) (tailcall $ 451 $ 452) halt (quote call-with-cont) (assign prev 453) (gosub list $ 453) (assign prev 454) (quote label) (assign prev 455) (gosub list $ 455) (assign prev 456) (gosub cadr $ 0) (assign prev 457) (gosub list $ 457) (assign prev 458) (gosub nth $ 0 2) (assign prev 459) (gosub list $ 459) (assign prev 460) (gosub list $ 1) (assign prev 461) (tailcall append $ 454 $ 456 $ 458 $ 460 $ 461) halt (gosub list $ 1) (assign prev 462) (gosub M $ 0) (assign prev 463) (gosub list $ 463) (assign prev 464) (tailcall append $ 462 $ 464) halt (atom? $ 1) (assign prev 465) (branch $ 465 1215) (gosub cadr $ 1) (assign prev 466) (car $ 466) (assign prev 467) (gosub nth $ 1 2) (assign prev 468) (tailcall substitute $ 467 $ 0 $ 468) halt (gosub list $ 1) (assign prev 469) (gosub list $ 0) (assign prev 470) (tailcall append $ 469 $ 470) halt)))

(define unfold-lambda-call (assemble '((assign arg# 0 0) (gosub cadr $ 0) (assign prev 1) (gosub unfold $ 1) (assign prev 2) (gosub list $ 2) (assign prev 3) (code (assign arg# 0 0) (quote assign) (assign prev 1) (gosub list $ 1) (assign prev 2) (gosub list $ 0) (assign prev 3) (tailcall append $ 2 $ 3) halt) (assign prev 4) (car $ 0) (assign prev 5) (gosub cadr $ 5) (assign prev 6) (gosub map $ 4 $ 6) (assign prev 7) (car $ 0) (assign prev 8) (gosub nth $ 8 2) (assign prev 9) (gosub unfold $ 9) (assign prev 10) (tailcall append $ 3 $ 7 $ 10) halt)))

(define unfold-branch (assemble '((assign arg# 0 0) (code (assign arg# 0 0) (quote branch) (assign prev 1) (gosub list $ 1) (assign prev 2) (env-ref cps-form) (assign prev 3) (gosub cadr $ 3) (assign prev 4) (gosub list $ 4) (assign prev 5) (gosub list $ 0) (assign prev 6) (gosub append $ 2 $ 5 $ 6) (assign prev 7) (gosub list $ 7) (assign prev 8) (env-ref cps-form) (assign prev 9) (gosub nth $ 9 3) (assign prev 10) (gosub unfold $ 10) (assign prev 11) (quote ->) (assign prev 12) (gosub list $ 12) (assign prev 13) (gosub list $ 0) (assign prev 14) (gosub append $ 13 $ 14) (assign prev 15) (gosub list $ 15) (assign prev 16) (env-ref cps-form) (assign prev 17) (gosub nth $ 17 2) (assign prev 18) (gosub unfold $ 18) (assign prev 19) (gosub append $ 8 $ 11 $ 16 $ 19) (assign prev 20) (tailcall progn $ 20) halt) (assign prev 1) (make-env $ 0 cps-form) (assign prev 2) (make-closure $ 1 $ 2) (assign prev 3) (gensym) (assign prev 4) (tailcall $ 3 $ 4) halt)))

(define unfold (assemble '((assign arg# 0 0) (code (assign arg# 0 0) (code (assign arg# 0 0) (code (assign arg# 0 0) (code (assign arg# 0 0) (code (assign arg# 0 0) (code (assign arg# 0 0) (env-ref cps) (assign prev 1) (atom? $ 1) (assign prev 2) (branch $ 2 90) (env-ref lambda-call?) (assign prev 3) (branch $ 3 84) (env-ref funcall?) (assign prev 4) (branch $ 4 66) (env-ref assignment?) (assign prev 5) (branch $ 5 48) (env-ref branch?) (assign prev 6) (branch $ 6 42) (env-ref halt?) (assign prev 7) (branch $ 7 32) (branch $ 0 28) (env-ref cps) (assign prev 8) (gosub list $ 8) (assign prev 9) (tailcall progn $ 9) halt (env-ref cps) (assign prev 10) (tailcall progn $ 10) halt (code (assign arg# 0 0) (atom? $ 0) (assign prev 1) (branch $ 1 16) (gosub unfold $ 0) (assign prev 2) (gosub list $ 2) (assign prev 3) (quote halt) (assign prev 4) (gosub list $ 4) (assign prev 5) (gosub append $ 3 $ 5) (assign prev 6) (tailcall progn $ 6) halt (gosub list $ 0) (assign prev 7) (quote halt) (assign prev 8) (gosub list $ 8) (assign prev 9) (gosub append $ 7 $ 9) (assign prev 10) (tailcall progn $ 10) halt) (assign prev 11) (env-ref cps) (assign prev 12) (gosub cadr $ 12) (assign prev 13) (gosub $ 11 $ 13) (assign prev 14) (tailcall progn $ 14) halt (env-ref cps) (assign prev 15) (gosub unfold-branch $ 15) (assign prev 16) (tailcall progn $ 16) halt (code (assign arg# 0 0) (quote assign) (assign prev 1) (gosub list $ 1) (assign prev 2) (gosub list $ 0) (assign prev 3) (tailcall append $ 2 $ 3) halt) (assign prev 17) (env-ref cps) (assign prev 18) (gosub cadr $ 18) (assign prev 19) (gosub map $ 17 $ 19) (assign prev 20) (env-ref cps) (assign prev 21) (gosub nth $ 21 2) (assign prev 22) (gosub unfold $ 22) (assign prev 23) (gosub append $ 20 $ 23) (assign prev 24) (tailcall progn $ 24) halt (env-ref cps) (assign prev 25) (gosub drop-last $ 25) (assign prev 26) (cdr $ 26) (assign prev 27) (gosub list $ 27) (assign prev 28) (env-ref cps) (assign prev 29) (gosub last $ 29) (assign prev 30) (gosub unfold $ 30) (assign prev 31) (gosub append $ 28 $ 31) (assign prev 32) (tailcall progn $ 32) halt (env-ref cps) (assign prev 33) (gosub unfold-lambda-call $ 33) (assign prev 34) (tailcall progn $ 34) halt (env-ref cps) (assign prev 35) (gosub list $ 35) (assign prev 36) (tailcall progn $ 36) halt) (assign prev 1) (make-env lambda-call? funcall? assignment? branch? $ 0 halt? cps) (assign prev 2) (make-closure $ 1 $ 2) (assign prev 3) (env-ref cps) (assign prev 4) (gosub list? $ 4) (assign prev 5) (gosub not $ 5) (assign prev 6) (branch $ 6 40) (env-ref cps) (assign prev 7) (car $ 7) (assign prev 8) (quote quote) (assign prev 9) (eq? $ 8 $ 9) (assign prev 10) (gosub not $ 10) (assign prev 11) (branch $ 11 38) (env-ref cps) (assign prev 12) (gosub count $ 12) (assign prev 13) (eq? $ 13 2) (assign prev 14) (gosub not $ 14) (assign prev 15) (branch $ 15 36) (tailcall $ 3 #t) halt (tailcall $ 3 #f) halt (tailcall $ 3 #f) halt (tailcall $ 3 #f) halt) (assign prev 1) (make-env lambda-call? funcall? assignment? $ 0 branch? cps) (assign prev 2) (make-closure $ 1 $ 2) (assign prev 3) (env-ref cps) (assign prev 4) (gosub list? $ 4) (assign prev 5) (gosub not $ 5) (assign prev 6) (branch $ 6 40) (env-ref cps) (assign prev 7) (car $ 7) (assign prev 8) (quote halt) (assign prev 9) (eq? $ 8 $ 9) (assign prev 10) (gosub not $ 10) (assign prev 11) (branch $ 11 38) (env-ref cps) (assign prev 12) (gosub count $ 12) (assign prev 13) (eq? $ 13 2) (assign prev 14) (gosub not $ 14) (assign prev 15) (branch $ 15 36) (tailcall $ 3 #t) halt (tailcall $ 3 #f) halt (tailcall $ 3 #f) halt (tailcall $ 3 #f) halt) (assign prev 1) (make-env lambda-call? funcall? $ 0 assignment? cps) (assign prev 2) (make-closure $ 1 $ 2) (assign prev 3) (env-ref cps) (assign prev 4) (gosub list? $ 4) (assign prev 5) (gosub not $ 5) (assign prev 6) (branch $ 6 40) (env-ref cps) (assign prev 7) (car $ 7) (assign prev 8) (quote branch) (assign prev 9) (eq? $ 8 $ 9) (assign prev 10) (gosub not $ 10) (assign prev 11) (branch $ 11 38) (env-ref cps) (assign prev 12) (gosub count $ 12) (assign prev 13) (eq? $ 13 4) (assign prev 14) (gosub not $ 14) (assign prev 15) (branch $ 15 36) (tailcall $ 3 #t) halt (tailcall $ 3 #f) halt (tailcall $ 3 #f) halt (tailcall $ 3 #f) halt) (assign prev 1) (make-env lambda-call? $ 0 funcall? cps) (assign prev 2) (make-closure $ 1 $ 2) (assign prev 3) (env-ref cps) (assign prev 4) (gosub list? $ 4) (assign prev 5) (gosub not $ 5) (assign prev 6) (branch $ 6 40) (env-ref cps) (assign prev 7) (car $ 7) (assign prev 8) (quote lambda) (assign prev 9) (eq? $ 8 $ 9) (assign prev 10) (gosub not $ 10) (assign prev 11) (branch $ 11 38) (env-ref cps) (assign prev 12) (gosub count $ 12) (assign prev 13) (eq? $ 13 3) (assign prev 14) (gosub not $ 14) (assign prev 15) (branch $ 15 36) (tailcall $ 3 #t) halt (tailcall $ 3 #f) halt (tailcall $ 3 #f) halt (tailcall $ 3 #f) halt) (assign prev 1) (make-env $ 0 lambda-call? cps) (assign prev 2) (make-closure $ 1 $ 2) (assign prev 3) (env-ref cps) (assign prev 4) (gosub list? $ 4) (assign prev 5) (gosub not $ 5) (assign prev 6) (branch $ 6 40) (env-ref cps) (assign prev 7) (car $ 7) (assign prev 8) (quote call-with-cont) (assign prev 9) (eq? $ 8 $ 9) (assign prev 10) (gosub not $ 10) (assign prev 11) (branch $ 11 38) (env-ref cps) (assign prev 12) (gosub count $ 12) (assign prev 13) (gosub >= $ 13 2) (assign prev 14) (gosub not $ 14) (assign prev 15) (branch $ 15 36) (tailcall $ 3 #t) halt (tailcall $ 3 #f) halt (tailcall $ 3 #f) halt (tailcall $ 3 #f) halt) (assign prev 1) (make-env $ 0 cps) (assign prev 2) (make-closure $ 1 $ 2) (assign prev 3) (gosub list? $ 0) (assign prev 4) (gosub not $ 4) (assign prev 5) (branch $ 5 54) (car $ 0) (assign prev 6) (gosub list? $ 6) (assign prev 7) (gosub not $ 7) (assign prev 8) (branch $ 8 52) (gosub caar $ 0) (assign prev 9) (quote lambda) (assign prev 10) (eq? $ 9 $ 10) (assign prev 11) (gosub not $ 11) (assign prev 12) (branch $ 12 50) (gosub count $ 0) (assign prev 13) (eq? $ 13 2) (assign prev 14) (gosub not $ 14) (assign prev 15) (branch $ 15 48) (car $ 0) (assign prev 16) (gosub count $ 16) (assign prev 17) (eq? $ 17 3) (assign prev 18) (gosub not $ 18) (assign prev 19) (branch $ 19 46) (tailcall $ 3 #t) halt (tailcall $ 3 #f) halt (tailcall $ 3 #f) halt (tailcall $ 3 #f) halt (tailcall $ 3 #f) halt (tailcall $ 3 #f) halt)))

(define fix-assignments (assemble '((assign arg# 0 0) (code (assign arg# 0 0) (code (assign arg# 0 0) (code (assign arg# 0 0) (assign arg# 1 1) (gosub list? $ 1) (assign prev 2) (branch $ 2 60) (type $ 1) (assign prev 3) (quote symbol) (assign prev 4) (eq? $ 3 $ 4) (assign prev 5) (gosub not $ 5) (assign prev 6) (branch $ 6 47) (env-ref gensym-alist) (assign prev 7) (gosub get $ 7 $ 1) (assign prev 8) (gosub not $ 8) (assign prev 9) (branch $ 9 34) (branch #t 24) (cons $ 1 $ 0) halt (quote $) (assign prev 10) (env-ref gensym-alist) (assign prev 11) (gosub get $ 11 $ 1) (assign prev 12) (gosub list $ 10 $ 12) (assign prev 13) (cons $ 13 $ 0) halt (branch #f 37) (cons $ 1 $ 0) halt (quote $) (assign prev 14) (env-ref gensym-alist) (assign prev 15) (gosub get $ 15 $ 1) (assign prev 16) (gosub list $ 14 $ 16) (assign prev 17) (cons $ 17 $ 0) halt (branch #f 50) (cons $ 1 $ 0) halt (quote $) (assign prev 18) (env-ref gensym-alist) (assign prev 19) (gosub get $ 19 $ 1) (assign prev 20) (gosub list $ 18 $ 20) (assign prev 21) (cons $ 21 $ 0) halt (car $ 1) (assign prev 22) (gosub list? $ 22) (assign prev 23) (branch $ 23 400) (car $ 1) (assign prev 24) (quote assign) (assign prev 25) (eq? $ 24 $ 25) (assign prev 26) (branch $ 26 103) (car $ 1) (assign prev 27) (quote make-env) (assign prev 28) (eq? $ 27 $ 28) (assign prev 29) (branch $ 29 91) (code (assign arg# 0 0) (assign arg# 1 1) (env-ref gensym-alist) (assign prev 2) (gosub get $ 2 $ 0) (assign prev 3) (branch $ 3 9) (cons $ 0 $ 1) halt (quote $) (assign prev 4) (env-ref gensym-alist) (assign prev 5) (gosub get $ 5 $ 0) (assign prev 6) (cons $ 6 $ 1) (assign prev 7) (cons $ 4 $ 7) halt) (assign prev 30) (make-env gensym-alist) (assign prev 31) (make-closure $ 30 $ 31) (assign prev 32) (quote ()) (assign prev 33) (gosub foldr $ 32 $ 33 $ 1) (assign prev 34) (cons $ 34 $ 0) halt (code (assign arg# 0 0) (assign arg# 1 1) (env-ref gensym-alist) (assign prev 2) (gosub get $ 2 $ 0) (assign prev 3) (branch $ 3 9) (cons $ 0 $ 1) halt (quote $) (assign prev 4) (gosub list $ 4) (assign prev 5) (env-ref gensym-alist) (assign prev 6) (gosub get $ 6 $ 0) (assign prev 7) (gosub list $ 7) (assign prev 8) (gosub list $ 0) (assign prev 9) (tailcall append $ 5 $ 8 $ 9 $ 1) halt) (assign prev 35) (make-env gensym-alist) (assign prev 36) (make-closure $ 35 $ 36) (assign prev 37) (quote ()) (assign prev 38) (gosub foldr $ 37 $ 38 $ 1) (assign prev 39) (cons $ 39 $ 0) halt (quote ()) (assign prev 40) (eq? $ 0 $ 40) (assign prev 41) (branch $ 41 305) (gosub caar $ 0) (assign prev 42) (quote assign) (assign prev 43) (eq? $ 42 $ 43) (assign prev 44) (branch $ 44 210) (branch #f 160) (quote stack-value) (assign prev 45) (env-ref stack-value) (assign prev 46) (gosub inc $ 46) (assign prev 47) (set! $ 45 $ 47) (assign prev 48) (quote gensym-alist) (assign prev 49) (env-ref gensym-alist) (assign prev 50) (gosub cadr $ 1) (assign prev 51) (env-ref stack-value) (assign prev 52) (gosub dec $ 52) (assign prev 53) (gosub constantly $ 53) (assign prev 54) (gosub update $ 50 $ 51 $ 54) (assign prev 55) (set! $ 49 $ 55) (assign prev 56) (quote assign) (assign prev 57) (gosub list $ 57) (assign prev 58) (quote prev) (assign prev 59) (gosub list $ 59) (assign prev 60) (env-ref stack-value) (assign prev 61) (gosub dec $ 61) (assign prev 62) (gosub list $ 62) (assign prev 63) (gosub append $ 58 $ 60 $ 63) (assign prev 64) (gosub progn $ 48 $ 56 $ 64) (assign prev 65) (cons $ 65 $ 0) halt (quote stack-value) (assign prev 66) (env-ref stack-value) (assign prev 67) (gosub inc $ 67) (assign prev 68) (set! $ 66 $ 68) (assign prev 69) (quote gensym-alist) (assign prev 70) (env-ref gensym-alist) (assign prev 71) (gosub cadr $ 1) (assign prev 72) (env-ref stack-value) (assign prev 73) (gosub dec $ 73) (assign prev 74) (gosub constantly $ 74) (assign prev 75) (gosub update $ 71 $ 72 $ 75) (assign prev 76) (set! $ 70 $ 76) (assign prev 77) (quote assign) (assign prev 78) (gosub list $ 78) (assign prev 79) (quote arg#) (assign prev 80) (gosub list $ 80) (assign prev 81) (env-ref stack-value) (assign prev 82) (gosub dec $ 82) (assign prev 83) (gosub list $ 83) (assign prev 84) (env-ref stack-value) (assign prev 85) (gosub dec $ 85) (assign prev 86) (gosub list $ 86) (assign prev 87) (gosub append $ 79 $ 81 $ 84 $ 87) (assign prev 88) (gosub progn $ 69 $ 77 $ 88) (assign prev 89) (cons $ 89 $ 0) halt (branch #t 255) (quote stack-value) (assign prev 90) (env-ref stack-value) (assign prev 91) (gosub inc $ 91) (assign prev 92) (set! $ 90 $ 92) (assign prev 93) (quote gensym-alist) (assign prev 94) (env-ref gensym-alist) (assign prev 95) (gosub cadr $ 1) (assign prev 96) (env-ref stack-value) (assign prev 97) (gosub dec $ 97) (assign prev 98) (gosub constantly $ 98) (assign prev 99) (gosub update $ 95 $ 96 $ 99) (assign prev 100) (set! $ 94 $ 100) (assign prev 101) (quote assign) (assign prev 102) (gosub list $ 102) (assign prev 103) (quote prev) (assign prev 104) (gosub list $ 104) (assign prev 105) (env-ref stack-value) (assign prev 106) (gosub dec $ 106) (assign prev 107) (gosub list $ 107) (assign prev 108) (gosub append $ 103 $ 105 $ 108) (assign prev 109) (gosub progn $ 93 $ 101 $ 109) (assign prev 110) (cons $ 110 $ 0) halt (quote stack-value) (assign prev 111) (env-ref stack-value) (assign prev 112) (gosub inc $ 112) (assign prev 113) (set! $ 111 $ 113) (assign prev 114) (quote gensym-alist) (assign prev 115) (env-ref gensym-alist) (assign prev 116) (gosub cadr $ 1) (assign prev 117) (env-ref stack-value) (assign prev 118) (gosub dec $ 118) (assign prev 119) (gosub constantly $ 119) (assign prev 120) (gosub update $ 116 $ 117 $ 120) (assign prev 121) (set! $ 115 $ 121) (assign prev 122) (quote assign) (assign prev 123) (gosub list $ 123) (assign prev 124) (quote arg#) (assign prev 125) (gosub list $ 125) (assign prev 126) (env-ref stack-value) (assign prev 127) (gosub dec $ 127) (assign prev 128) (gosub list $ 128) (assign prev 129) (env-ref stack-value) (assign prev 130) (gosub dec $ 130) (assign prev 131) (gosub list $ 131) (assign prev 132) (gosub append $ 124 $ 126 $ 129 $ 132) (assign prev 133) (gosub progn $ 114 $ 122 $ 133) (assign prev 134) (cons $ 134 $ 0) halt (branch #t 350) (quote stack-value) (assign prev 135) (env-ref stack-value) (assign prev 136) (gosub inc $ 136) (assign prev 137) (set! $ 135 $ 137) (assign prev 138) (quote gensym-alist) (assign prev 139) (env-ref gensym-alist) (assign prev 140) (gosub cadr $ 1) (assign prev 141) (env-ref stack-value) (assign prev 142) (gosub dec $ 142) (assign prev 143) (gosub constantly $ 143) (assign prev 144) (gosub update $ 140 $ 141 $ 144) (assign prev 145) (set! $ 139 $ 145) (assign prev 146) (quote assign) (assign prev 147) (gosub list $ 147) (assign prev 148) (quote prev) (assign prev 149) (gosub list $ 149) (assign prev 150) (env-ref stack-value) (assign prev 151) (gosub dec $ 151) (assign prev 152) (gosub list $ 152) (assign prev 153) (gosub append $ 148 $ 150 $ 153) (assign prev 154) (gosub progn $ 138 $ 146 $ 154) (assign prev 155) (cons $ 155 $ 0) halt (quote stack-value) (assign prev 156) (env-ref stack-value) (assign prev 157) (gosub inc $ 157) (assign prev 158) (set! $ 156 $ 158) (assign prev 159) (quote gensym-alist) (assign prev 160) (env-ref gensym-alist) (assign prev 161) (gosub cadr $ 1) (assign prev 162) (env-ref stack-value) (assign prev 163) (gosub dec $ 163) (assign prev 164) (gosub constantly $ 164) (assign prev 165) (gosub update $ 161 $ 162 $ 165) (assign prev 166) (set! $ 160 $ 166) (assign prev 167) (quote assign) (assign prev 168) (gosub list $ 168) (assign prev 169) (quote arg#) (assign prev 170) (gosub list $ 170) (assign prev 171) (env-ref stack-value) (assign prev 172) (gosub dec $ 172) (assign prev 173) (gosub list $ 173) (assign prev 174) (env-ref stack-value) (assign prev 175) (gosub dec $ 175) (assign prev 176) (gosub list $ 176) (assign prev 177) (gosub append $ 169 $ 171 $ 174 $ 177) (assign prev 178) (gosub progn $ 159 $ 167 $ 178) (assign prev 179) (cons $ 179 $ 0) halt (cons $ 1 $ 0) halt) (assign prev 1) (make-env stack-value $ 0 gensym-alist) (assign prev 2) (make-closure $ 1 $ 2) (assign prev 3) (quote ()) (assign prev 4) (env-ref instructions) (assign prev 5) (gosub foldl $ 3 $ 4 $ 5) (assign prev 6) (gosub reverse $ 6) (assign prev 7) (tailcall progn $ 7) halt) (assign prev 1) (make-env $ 0 stack-value instructions) (assign prev 2) (make-closure $ 1 $ 2) (assign prev 3) (quote ()) (assign prev 4) (tailcall $ 3 $ 4) halt) (assign prev 1) (make-env $ 0 instructions) (assign prev 2) (make-closure $ 1 $ 2) (assign prev 3) (tailcall $ 3 0) halt)))

(define scan (assemble '((assign arg# 0 0) (assign arg# 1 1) (assign arg# 2 2) (code (assign arg# 0 0) (assign arg# 1 1) (env-ref f) (assign prev 2) (car $ 0) (assign prev 3) (gosub $ 2 $ 3 $ 1) (assign prev 4) (cons $ 4 $ 0) halt) (assign prev 3) (make-env $ 0 f) (assign prev 4) (make-closure $ 3 $ 4) (assign prev 5) (gosub list $ 1) (assign prev 6) (gosub foldl $ 5 $ 6 $ 2) (assign prev 7) (tailcall reverse $ 7) halt)))

(define fix-branches (assemble '((assign arg# 0 0) (code (assign arg# 0 0) (code (assign arg# 0 0) (assign arg# 1 1) (code (assign arg# 0 0) (code (assign arg# 0 0) (env-ref instruction) (assign prev 1) (gosub list? $ 1) (assign prev 2) (gosub not $ 2) (assign prev 3) (branch $ 3 616) (env-ref instruction) (assign prev 4) (gosub count $ 4) (assign prev 5) (eq? $ 5 2) (assign prev 6) (gosub not $ 6) (assign prev 7) (branch $ 7 420) (env-ref instruction) (assign prev 8) (car $ 8) (assign prev 9) (quote ->) (assign prev 10) (eq? $ 9 $ 10) (assign prev 11) (gosub not $ 11) (assign prev 12) (branch $ 12 224) (branch #t 204) (env-ref instruction) (assign prev 13) (gosub list? $ 13) (assign prev 14) (gosub not $ 14) (assign prev 15) (branch $ 15 167) (env-ref instruction) (assign prev 16) (gosub count $ 16) (assign prev 17) (gosub >= $ 17 2) (assign prev 18) (gosub not $ 18) (assign prev 19) (branch $ 19 130) (env-ref instruction) (assign prev 20) (car $ 20) (assign prev 21) (quote branch) (assign prev 22) (eq? $ 21 $ 22) (assign prev 23) (gosub not $ 23) (assign prev 24) (branch $ 24 93) (branch #t 65) (env-ref instruction) (assign prev 25) (env-ref acc) (assign prev 26) (cons $ 25 $ 26) (assign prev 27) (tailcall progn $ 27) halt (quote branch) (assign prev 28) (gosub list $ 28) (assign prev 29) (env-ref instruction) (assign prev 30) (gosub drop-last $ 30) (assign prev 31) (cdr $ 31) (assign prev 32) (env-ref goto-alist) (assign prev 33) (env-ref instruction) (assign prev 34) (gosub last $ 34) (assign prev 35) (gosub get $ 33 $ 35) (assign prev 36) (gosub list $ 36) (assign prev 37) (gosub append $ 29 $ 32 $ 37) (assign prev 38) (env-ref acc) (assign prev 39) (cons $ 38 $ 39) (assign prev 40) (tailcall progn $ 40) halt (branch #f 102) (env-ref instruction) (assign prev 41) (env-ref acc) (assign prev 42) (cons $ 41 $ 42) (assign prev 43) (tailcall progn $ 43) halt (quote branch) (assign prev 44) (gosub list $ 44) (assign prev 45) (env-ref instruction) (assign prev 46) (gosub drop-last $ 46) (assign prev 47) (cdr $ 47) (assign prev 48) (env-ref goto-alist) (assign prev 49) (env-ref instruction) (assign prev 50) (gosub last $ 50) (assign prev 51) (gosub get $ 49 $ 51) (assign prev 52) (gosub list $ 52) (assign prev 53) (gosub append $ 45 $ 48 $ 53) (assign prev 54) (env-ref acc) (assign prev 55) (cons $ 54 $ 55) (assign prev 56) (tailcall progn $ 56) halt (branch #f 139) (env-ref instruction) (assign prev 57) (env-ref acc) (assign prev 58) (cons $ 57 $ 58) (assign prev 59) (tailcall progn $ 59) halt (quote branch) (assign prev 60) (gosub list $ 60) (assign prev 61) (env-ref instruction) (assign prev 62) (gosub drop-last $ 62) (assign prev 63) (cdr $ 63) (assign prev 64) (env-ref goto-alist) (assign prev 65) (env-ref instruction) (assign prev 66) (gosub last $ 66) (assign prev 67) (gosub get $ 65 $ 67) (assign prev 68) (gosub list $ 68) (assign prev 69) (gosub append $ 61 $ 64 $ 69) (assign prev 70) (env-ref acc) (assign prev 71) (cons $ 70 $ 71) (assign prev 72) (tailcall progn $ 72) halt (branch #f 176) (env-ref instruction) (assign prev 73) (env-ref acc) (assign prev 74) (cons $ 73 $ 74) (assign prev 75) (tailcall progn $ 75) halt (quote branch) (assign prev 76) (gosub list $ 76) (assign prev 77) (env-ref instruction) (assign prev 78) (gosub drop-last $ 78) (assign prev 79) (cdr $ 79) (assign prev 80) (env-ref goto-alist) (assign prev 81) (env-ref instruction) (assign prev 82) (gosub last $ 82) (assign prev 83) (gosub get $ 81 $ 83) (assign prev 84) (gosub list $ 84) (assign prev 85) (gosub append $ 77 $ 80 $ 85) (assign prev 86) (env-ref acc) (assign prev 87) (cons $ 86 $ 87) (assign prev 88) (tailcall progn $ 88) halt (quote goto-alist) (assign prev 89) (env-ref goto-alist) (assign prev 90) (env-ref instruction) (assign prev 91) (gosub cadr $ 91) (assign prev 92) (gosub constantly $ 0) (assign prev 93) (gosub update $ 90 $ 92 $ 93) (assign prev 94) (set! $ 89 $ 94) (assign prev 95) (env-ref acc) (assign prev 96) (gosub progn $ 95 $ 96) (assign prev 97) (tailcall progn $ 97) halt (branch #f 400) (env-ref instruction) (assign prev 98) (gosub list? $ 98) (assign prev 99) (gosub not $ 99) (assign prev 100) (branch $ 100 363) (env-ref instruction) (assign prev 101) (gosub count $ 101) (assign prev 102) (gosub >= $ 102 2) (assign prev 103) (gosub not $ 103) (assign prev 104) (branch $ 104 326) (env-ref instruction) (assign prev 105) (car $ 105) (assign prev 106) (quote branch) (assign prev 107) (eq? $ 106 $ 107) (assign prev 108) (gosub not $ 108) (assign prev 109) (branch $ 109 289) (branch #t 261) (env-ref instruction) (assign prev 110) (env-ref acc) (assign prev 111) (cons $ 110 $ 111) (assign prev 112) (tailcall progn $ 112) halt (quote branch) (assign prev 113) (gosub list $ 113) (assign prev 114) (env-ref instruction) (assign prev 115) (gosub drop-last $ 115) (assign prev 116) (cdr $ 116) (assign prev 117) (env-ref goto-alist) (assign prev 118) (env-ref instruction) (assign prev 119) (gosub last $ 119) (assign prev 120) (gosub get $ 118 $ 120) (assign prev 121) (gosub list $ 121) (assign prev 122) (gosub append $ 114 $ 117 $ 122) (assign prev 123) (env-ref acc) (assign prev 124) (cons $ 123 $ 124) (assign prev 125) (tailcall progn $ 125) halt (branch #f 298) (env-ref instruction) (assign prev 126) (env-ref acc) (assign prev 127) (cons $ 126 $ 127) (assign prev 128) (tailcall progn $ 128) halt (quote branch) (assign prev 129) (gosub list $ 129) (assign prev 130) (env-ref instruction) (assign prev 131) (gosub drop-last $ 131) (assign prev 132) (cdr $ 132) (assign prev 133) (env-ref goto-alist) (assign prev 134) (env-ref instruction) (assign prev 135) (gosub last $ 135) (assign prev 136) (gosub get $ 134 $ 136) (assign prev 137) (gosub list $ 137) (assign prev 138) (gosub append $ 130 $ 133 $ 138) (assign prev 139) (env-ref acc) (assign prev 140) (cons $ 139 $ 140) (assign prev 141) (tailcall progn $ 141) halt (branch #f 335) (env-ref instruction) (assign prev 142) (env-ref acc) (assign prev 143) (cons $ 142 $ 143) (assign prev 144) (tailcall progn $ 144) halt (quote branch) (assign prev 145) (gosub list $ 145) (assign prev 146) (env-ref instruction) (assign prev 147) (gosub drop-last $ 147) (assign prev 148) (cdr $ 148) (assign prev 149) (env-ref goto-alist) (assign prev 150) (env-ref instruction) (assign prev 151) (gosub last $ 151) (assign prev 152) (gosub get $ 150 $ 152) (assign prev 153) (gosub list $ 153) (assign prev 154) (gosub append $ 146 $ 149 $ 154) (assign prev 155) (env-ref acc) (assign prev 156) (cons $ 155 $ 156) (assign prev 157) (tailcall progn $ 157) halt (branch #f 372) (env-ref instruction) (assign prev 158) (env-ref acc) (assign prev 159) (cons $ 158 $ 159) (assign prev 160) (tailcall progn $ 160) halt (quote branch) (assign prev 161) (gosub list $ 161) (assign prev 162) (env-ref instruction) (assign prev 163) (gosub drop-last $ 163) (assign prev 164) (cdr $ 164) (assign prev 165) (env-ref goto-alist) (assign prev 166) (env-ref instruction) (assign prev 167) (gosub last $ 167) (assign prev 168) (gosub get $ 166 $ 168) (assign prev 169) (gosub list $ 169) (assign prev 170) (gosub append $ 162 $ 165 $ 170) (assign prev 171) (env-ref acc) (assign prev 172) (cons $ 171 $ 172) (assign prev 173) (tailcall progn $ 173) halt (quote goto-alist) (assign prev 174) (env-ref goto-alist) (assign prev 175) (env-ref instruction) (assign prev 176) (gosub cadr $ 176) (assign prev 177) (gosub constantly $ 0) (assign prev 178) (gosub update $ 175 $ 177 $ 178) (assign prev 179) (set! $ 174 $ 179) (assign prev 180) (env-ref acc) (assign prev 181) (gosub progn $ 180 $ 181) (assign prev 182) (tailcall progn $ 182) halt (branch #f 596) (env-ref instruction) (assign prev 183) (gosub list? $ 183) (assign prev 184) (gosub not $ 184) (assign prev 185) (branch $ 185 559) (env-ref instruction) (assign prev 186) (gosub count $ 186) (assign prev 187) (gosub >= $ 187 2) (assign prev 188) (gosub not $ 188) (assign prev 189) (branch $ 189 522) (env-ref instruction) (assign prev 190) (car $ 190) (assign prev 191) (quote branch) (assign prev 192) (eq? $ 191 $ 192) (assign prev 193) (gosub not $ 193) (assign prev 194) (branch $ 194 485) (branch #t 457) (env-ref instruction) (assign prev 195) (env-ref acc) (assign prev 196) (cons $ 195 $ 196) (assign prev 197) (tailcall progn $ 197) halt (quote branch) (assign prev 198) (gosub list $ 198) (assign prev 199) (env-ref instruction) (assign prev 200) (gosub drop-last $ 200) (assign prev 201) (cdr $ 201) (assign prev 202) (env-ref goto-alist) (assign prev 203) (env-ref instruction) (assign prev 204) (gosub last $ 204) (assign prev 205) (gosub get $ 203 $ 205) (assign prev 206) (gosub list $ 206) (assign prev 207) (gosub append $ 199 $ 202 $ 207) (assign prev 208) (env-ref acc) (assign prev 209) (cons $ 208 $ 209) (assign prev 210) (tailcall progn $ 210) halt (branch #f 494) (env-ref instruction) (assign prev 211) (env-ref acc) (assign prev 212) (cons $ 211 $ 212) (assign prev 213) (tailcall progn $ 213) halt (quote branch) (assign prev 214) (gosub list $ 214) (assign prev 215) (env-ref instruction) (assign prev 216) (gosub drop-last $ 216) (assign prev 217) (cdr $ 217) (assign prev 218) (env-ref goto-alist) (assign prev 219) (env-ref instruction) (assign prev 220) (gosub last $ 220) (assign prev 221) (gosub get $ 219 $ 221) (assign prev 222) (gosub list $ 222) (assign prev 223) (gosub append $ 215 $ 218 $ 223) (assign prev 224) (env-ref acc) (assign prev 225) (cons $ 224 $ 225) (assign prev 226) (tailcall progn $ 226) halt (branch #f 531) (env-ref instruction) (assign prev 227) (env-ref acc) (assign prev 228) (cons $ 227 $ 228) (assign prev 229) (tailcall progn $ 229) halt (quote branch) (assign prev 230) (gosub list $ 230) (assign prev 231) (env-ref instruction) (assign prev 232) (gosub drop-last $ 232) (assign prev 233) (cdr $ 233) (assign prev 234) (env-ref goto-alist) (assign prev 235) (env-ref instruction) (assign prev 236) (gosub last $ 236) (assign prev 237) (gosub get $ 235 $ 237) (assign prev 238) (gosub list $ 238)
																		   (assign prev 239) (gosub append $ 231 $ 234 $ 239) (assign prev 240) (env-ref acc) (assign prev 241) (cons $ 240 $ 241) (assign prev 242) (tailcall progn $ 242) halt (branch #f 568) (env-ref instruction) (assign prev 243) (env-ref acc) (assign prev 244) (cons $ 243 $ 244) (assign prev 245) (tailcall progn $ 245) halt (quote branch) (assign prev 246) (gosub list $ 246) (assign prev 247) (env-ref instruction) (assign prev 248) (gosub drop-last $ 248) (assign prev 249) (cdr $ 249) (assign prev 250) (env-ref goto-alist) (assign prev 251) (env-ref instruction) (assign prev 252) (gosub last $ 252) (assign prev 253) (gosub get $ 251 $ 253) (assign prev 254) (gosub list $ 254) (assign prev 255) (gosub append $ 247 $ 250 $ 255) (assign prev 256) (env-ref acc) (assign prev 257) (cons $ 256 $ 257) (assign prev 258) (tailcall progn $ 258) halt (quote goto-alist) (assign prev 259) (env-ref goto-alist) (assign prev 260) (env-ref instruction) (assign prev 261) (gosub cadr $ 261) (assign prev 262) (gosub constantly $ 0) (assign prev 263) (gosub update $ 260 $ 262 $ 263) (assign prev 264) (set! $ 259 $ 264) (assign prev 265) (env-ref acc) (assign prev 266) (gosub progn $ 265 $ 266) (assign prev 267) (tailcall progn $ 267) halt (branch #f 792) (env-ref instruction) (assign prev 268) (gosub list? $ 268) (assign prev 269) (gosub not $ 269) (assign prev 270) (branch $ 270 755) (env-ref instruction) (assign prev 271) (gosub count $ 271) (assign prev 272) (gosub >= $ 272 2) (assign prev 273) (gosub not $ 273) (assign prev 274) (branch $ 274 718) (env-ref instruction) (assign prev 275) (car $ 275) (assign prev 276) (quote branch) (assign prev 277) (eq? $ 276 $ 277) (assign prev 278) (gosub not $ 278) (assign prev 279) (branch $ 279 681) (branch #t 653) (env-ref instruction) (assign prev 280) (env-ref acc) (assign prev 281) (cons $ 280 $ 281) (assign prev 282) (tailcall progn $ 282) halt (quote branch) (assign prev 283) (gosub list $ 283) (assign prev 284) (env-ref instruction) (assign prev 285) (gosub drop-last $ 285) (assign prev 286) (cdr $ 286) (assign prev 287) (env-ref goto-alist) (assign prev 288) (env-ref instruction) (assign prev 289) (gosub last $ 289) (assign prev 290) (gosub get $ 288 $ 290) (assign prev 291) (gosub list $ 291) (assign prev 292) (gosub append $ 284 $ 287 $ 292) (assign prev 293) (env-ref acc) (assign prev 294) (cons $ 293 $ 294) (assign prev 295) (tailcall progn $ 295) halt (branch #f 690) (env-ref instruction) (assign prev 296) (env-ref acc) (assign prev 297) (cons $ 296 $ 297) (assign prev 298) (tailcall progn $ 298) halt (quote branch) (assign prev 299) (gosub list $ 299) (assign prev 300) (env-ref instruction) (assign prev 301) (gosub drop-last $ 301) (assign prev 302) (cdr $ 302) (assign prev 303) (env-ref goto-alist) (assign prev 304) (env-ref instruction) (assign prev 305) (gosub last $ 305) (assign prev 306) (gosub get $ 304 $ 306) (assign prev 307) (gosub list $ 307) (assign prev 308) (gosub append $ 300 $ 303 $ 308) (assign prev 309) (env-ref acc) (assign prev 310) (cons $ 309 $ 310) (assign prev 311) (tailcall progn $ 311) halt (branch #f 727) (env-ref instruction) (assign prev 312) (env-ref acc) (assign prev 313) (cons $ 312 $ 313) (assign prev 314) (tailcall progn $ 314) halt (quote branch) (assign prev 315) (gosub list $ 315) (assign prev 316) (env-ref instruction) (assign prev 317) (gosub drop-last $ 317) (assign prev 318) (cdr $ 318) (assign prev 319) (env-ref goto-alist) (assign prev 320) (env-ref instruction) (assign prev 321) (gosub last $ 321) (assign prev 322) (gosub get $ 320 $ 322) (assign prev 323) (gosub list $ 323) (assign prev 324) (gosub append $ 316 $ 319 $ 324) (assign prev 325) (env-ref acc) (assign prev 326) (cons $ 325 $ 326) (assign prev 327) (tailcall progn $ 327) halt (branch #f 764) (env-ref instruction) (assign prev 328) (env-ref acc) (assign prev 329) (cons $ 328 $ 329) (assign prev 330) (tailcall progn $ 330) halt (quote branch) (assign prev 331) (gosub list $ 331) (assign prev 332) (env-ref instruction) (assign prev 333) (gosub drop-last $ 333) (assign prev 334) (cdr $ 334) (assign prev 335) (env-ref goto-alist) (assign prev 336) (env-ref instruction) (assign prev 337) (gosub last $ 337) (assign prev 338) (gosub get $ 336 $ 338) (assign prev 339) (gosub list $ 339) (assign prev 340) (gosub append $ 332 $ 335 $ 340) (assign prev 341) (env-ref acc) (assign prev 342) (cons $ 341 $ 342) (assign prev 343) (tailcall progn $ 343) halt (quote goto-alist) (assign prev 344) (env-ref goto-alist) (assign prev 345) (env-ref instruction) (assign prev 346) (gosub cadr $ 346) (assign prev 347) (gosub constantly $ 0) (assign prev 348) (gosub update $ 345 $ 347 $ 348) (assign prev 349) (set! $ 344 $ 349) (assign prev 350) (env-ref acc) (assign prev 351) (gosub progn $ 350 $ 351) (assign prev 352) (tailcall progn $ 352) halt) (assign prev 1) (make-env goto-alist $ 0 instruction acc) (assign prev 2) (make-closure $ 1 $ 2) (assign prev 3) (env-ref instruction-and-line-num) (assign prev 4) (gosub cadr $ 4) (assign prev 5) (tailcall $ 3 $ 5) halt) (assign prev 2) (make-env goto-alist $ 1 acc $ 0 instruction-and-line-num) (assign prev 3) (make-closure $ 2 $ 3) (assign prev 4) (car $ 0) (assign prev 5) (tailcall $ 4 $ 5) halt) (assign prev 1) (make-env $ 0 goto-alist) (assign prev 2) (make-closure $ 1 $ 2) (assign prev 3) (quote ()) (assign prev 4) (env-ref instructions) (assign prev 5) (code (assign arg# 0 0) (assign arg# 1 1) (atom? $ 1) (assign prev 2) (gosub not $ 2) (assign prev 3) (gosub not $ 3) (assign prev 4) (branch $ 4 28) (car $ 1) (assign prev 5) (quote ->) (assign prev 6) (eq? $ 5 $ 6) (assign prev 7) (gosub not $ 7) (assign prev 8) (branch $ 8 23) (branch #t 21) (tailcall inc $ 0) halt ($ 0) halt (branch #f 26) (tailcall inc $ 0) halt ($ 0) halt (branch #f 31) (tailcall inc $ 0) halt ($ 0) halt) (assign prev 6) (env-ref instructions) (assign prev 7) (gosub scan $ 6 0 $ 7) (assign prev 8) (gosub zip $ 5 $ 8) (assign prev 9) (gosub foldr $ 3 $ 4 $ 9) (assign prev 10) (tailcall progn $ 10) halt) (assign prev 1) (make-env $ 0 instructions) (assign prev 2) (make-closure $ 1 $ 2) (assign prev 3) (quote ()) (assign prev 4) (tailcall $ 3 $ 4) halt)))

(define add-tailcalls (assemble '((assign arg# 0 0) (code (assign arg# 0 0) (assign arg# 1 1) (quote ()) (assign prev 2) (eq? $ 1 $ 2) (assign prev 3) (branch $ 3 116) (car $ 1) (assign prev 4) (quote halt) (assign prev 5) (eq? $ 4 $ 5) (assign prev 6) (gosub not $ 6) (assign prev 7) (branch $ 7 66) (branch #f 64) (gosub list? $ 0) (assign prev 8) (gosub not $ 8) (assign prev 9) (branch $ 9 53) (car $ 0) (assign prev 10) (quote gosub) (assign prev 11) (eq? $ 10 $ 11) (assign prev 12) (gosub not $ 12) (assign prev 13) (branch $ 13 42) (branch #t 34) (cons $ 0 $ 1) halt (quote tailcall) (assign prev 14) (cdr $ 0) (assign prev 15) (cons $ 14 $ 15) (assign prev 16) (cons $ 16 $ 1) halt (branch #f 45) (cons $ 0 $ 1) halt (quote tailcall) (assign prev 17) (cdr $ 0) (assign prev 18) (cons $ 17 $ 18) (assign prev 19) (cons $ 19 $ 1) halt (branch #f 56) (cons $ 0 $ 1) halt (quote tailcall) (assign prev 20) (cdr $ 0) (assign prev 21) (cons $ 20 $ 21) (assign prev 22) (cons $ 22 $ 1) halt (cons $ 0 $ 1) halt (branch #t 114) (gosub list? $ 0) (assign prev 23) (gosub not $ 23) (assign prev 24) (branch $ 24 103) (car $ 0) (assign prev 25) (quote gosub) (assign prev 26) (eq? $ 25 $ 26) (assign prev 27) (gosub not $ 27) (assign prev 28) (branch $ 28 92) (branch #t 84) (cons $ 0 $ 1) halt (quote tailcall) (assign prev 29) (cdr $ 0) (assign prev 30) (cons $ 29 $ 30) (assign prev 31) (cons $ 31 $ 1) halt (branch #f 95) (cons $ 0 $ 1) halt (quote tailcall) (assign prev 32) (cdr $ 0) (assign prev 33) (cons $ 32 $ 33) (assign prev 34) (cons $ 34 $ 1) halt (branch #f 106) (cons $ 0 $ 1) halt (quote tailcall) (assign prev 35) (cdr $ 0) (assign prev 36) (cons $ 35 $ 36) (assign prev 37) (cons $ 37 $ 1) halt (cons $ 0 $ 1) halt (branch #t 164) (gosub list? $ 0) (assign prev 38) (gosub not $ 38) (assign prev 39) (branch $ 39 153) (car $ 0) (assign prev 40) (quote gosub) (assign prev 41) (eq? $ 40 $ 41) (assign prev 42) (gosub not $ 42) (assign prev 43) (branch $ 43 142) (branch #t 134) (cons $ 0 $ 1) halt (quote tailcall) (assign prev 44) (cdr $ 0) (assign prev 45) (cons $ 44 $ 45) (assign prev 46) (cons $ 46 $ 1) halt (branch #f 145) (cons $ 0 $ 1) halt (quote tailcall) (assign prev 47) (cdr $ 0) (assign prev 48) (cons $ 47 $ 48) (assign prev 49) (cons $ 49 $ 1) halt (branch #f 156) (cons $ 0 $ 1) halt (quote tailcall) (assign prev 50) (cdr $ 0) (assign prev 51) (cons $ 50 $ 51) (assign prev 52) (cons $ 52 $ 1) halt (cons $ 0 $ 1) halt) (assign prev 1) (quote ()) (assign prev 2) (tailcall foldr $ 1 $ 2 $ 0) halt)))

(define get-immediate-lambdas (assemble '((assign arg# 0 0) (gosub list? $ 0) (assign prev 1) (branch $ 1 6) (quote ()) halt (car $ 0) (assign prev 2) (quote lambda) (assign prev 3) (eq? $ 2 $ 3) (assign prev 4) (branch $ 4 15) (tailcall mapcat get-immediate-lambdas $ 0) halt (tailcall list $ 0) halt)))

(define mark-var-args (assemble '((assign arg# 0 0) (assign arg# 1 1) (code (assign arg# 0 0) (code (assign arg# 0 0) (env-ref expression) (assign prev 1) (gosub list? $ 1) (assign prev 2) (gosub not $ 2) (assign prev 3) (branch $ 3 67) (env-ref expression) (assign prev 4) (car $ 4) (assign prev 5) (quote lambda) (assign prev 6) (eq? $ 5 $ 6) (assign prev 7) (gosub not $ 7) (assign prev 8) (branch $ 8 54) (env-ref expression) (assign prev 9) (gosub cadr $ 9) (assign prev 10) (atom? $ 10) (assign prev 11) (gosub not $ 11) (assign prev 12) (branch $ 12 41) (branch #t 31) (tailcall progn $ 0) halt (code (assign arg# 0 0) (car $ 0) (assign prev 1) (quote code) (assign prev 2) (eq? $ 1 $ 2) (assign prev 3) (branch $ 3 14) (quote (var-arg)) (assign prev 4) (cons $ 4 $ 0) (assign prev 5) (tailcall progn $ 5) halt (quote code) (assign prev 6) (quote (var-arg)) (assign prev 7) (cdr $ 0) (assign prev 8) (cons $ 7 $ 8) (assign prev 9) (cons $ 6 $ 9) (assign prev 10) (tailcall progn $ 10) halt) (assign prev 13) (code (assign arg# 0 0) (gosub list? $ 0) (assign prev 1) (gosub not $ 1) (assign prev 2) (branch $ 2 41) (car $ 0) (assign prev 3) (quote branch) (assign prev 4) (eq? $ 3 $ 4) (assign prev 5) (gosub not $ 5) (assign prev 6) (branch $ 6 28) (branch #t 18) ($ 0) halt (gosub drop-last $ 0) (assign prev 7) (gosub last $ 0) (assign prev 8) (gosub inc $ 8) (assign prev 9) (gosub list $ 9) (assign prev 10) (tailcall append $ 7 $ 10) halt (branch #f 31) ($ 0) halt (gosub drop-last $ 0) (assign prev 11) (gosub last $ 0) (assign prev 12) (gosub inc $ 12) (assign prev 13) (gosub list $ 13) (assign prev 14) (tailcall append $ 11 $ 14) halt (branch #f 44) ($ 0) halt (gosub drop-last $ 0) (assign prev 15) (gosub last $ 0) (assign prev 16) (gosub inc $ 16) (assign prev 17) (gosub list $ 17) (assign prev 18) (tailcall append $ 15 $ 18) halt) (assign prev 14) (gosub map $ 14 $ 0) (assign prev 15) (gosub $ 13 $ 15) (assign prev 16) (tailcall progn $ 16) halt (branch #f 44) (tailcall progn $ 0) halt (code (assign arg# 0 0) (car $ 0) (assign prev 1) (quote code) (assign prev 2) (eq? $ 1 $ 2) (assign prev 3) (branch $ 3 14) (quote (var-arg)) (assign prev 4) (cons $ 4 $ 0) (assign prev 5) (tailcall progn $ 5) halt (quote code) (assign prev 6) (quote (var-arg)) (assign prev 7) (cdr $ 0) (assign prev 8) (cons $ 7 $ 8) (assign prev 9) (cons $ 6 $ 9) (assign prev 10) (tailcall progn $ 10) halt) (assign prev 17) (code (assign arg# 0 0) (gosub list? $ 0) (assign prev 1) (gosub not $ 1) (assign prev 2) (branch $ 2 41) (car $ 0) (assign prev 3) (quote branch) (assign prev 4) (eq? $ 3 $ 4) (assign prev 5) (gosub not $ 5) (assign prev 6) (branch $ 6 28) (branch #t 18) ($ 0) halt (gosub drop-last $ 0) (assign prev 7) (gosub last $ 0) (assign prev 8) (gosub inc $ 8) (assign prev 9) (gosub list $ 9) (assign prev 10) (tailcall append $ 7 $ 10) halt (branch #f 31) ($ 0) halt (gosub drop-last $ 0) (assign prev 11) (gosub last $ 0) (assign prev 12) (gosub inc $ 12) (assign prev 13) (gosub list $ 13) (assign prev 14) (tailcall append $ 11 $ 14) halt (branch #f 44) ($ 0) halt (gosub drop-last $ 0) (assign prev 15) (gosub last $ 0) (assign prev 16) (gosub inc $ 16) (assign prev 17) (gosub list $ 17) (assign prev 18) (tailcall append $ 15 $ 18) halt) (assign prev 18) (gosub map $ 18 $ 0) (assign prev 19) (gosub $ 17 $ 19) (assign prev 20) (tailcall progn $ 20) halt (branch #f 57) (tailcall progn $ 0) halt (code (assign arg# 0 0) (car $ 0) (assign prev 1) (quote code) (assign prev 2) (eq? $ 1 $ 2) (assign prev 3) (branch $ 3 14) (quote (var-arg)) (assign prev 4) (cons $ 4 $ 0) (assign prev 5) (tailcall progn $ 5) halt (quote code) (assign prev 6) (quote (var-arg)) (assign prev 7) (cdr $ 0) (assign prev 8) (cons $ 7 $ 8) (assign prev 9) (cons $ 6 $ 9) (assign prev 10) (tailcall progn $ 10) halt) (assign prev 21) (code (assign arg# 0 0) (gosub list? $ 0) (assign prev 1) (gosub not $ 1) (assign prev 2) (branch $ 2 41) (car $ 0) (assign prev 3) (quote branch) (assign prev 4) (eq? $ 3 $ 4) (assign prev 5) (gosub not $ 5) (assign prev 6) (branch $ 6 28) (branch #t 18) ($ 0) halt (gosub drop-last $ 0) (assign prev 7) (gosub last $ 0) (assign prev 8) (gosub inc $ 8) (assign prev 9) (gosub list $ 9) (assign prev 10) (tailcall append $ 7 $ 10) halt (branch #f 31) ($ 0) halt (gosub drop-last $ 0) (assign prev 11) (gosub last $ 0) (assign prev 12) (gosub inc $ 12) (assign prev 13) (gosub list $ 13) (assign prev 14) (tailcall append $ 11 $ 14) halt (branch #f 44) ($ 0) halt (gosub drop-last $ 0) (assign prev 15) (gosub last $ 0) (assign prev 16) (gosub inc $ 16) (assign prev 17) (gosub list $ 17) (assign prev 18) (tailcall append $ 15 $ 18) halt) (assign prev 22) (gosub map $ 22 $ 0) (assign prev 23) (gosub $ 21 $ 23) (assign prev 24) (tailcall progn $ 24) halt (branch #f 70) (tailcall progn $ 0) halt (code (assign arg# 0 0) (car $ 0) (assign prev 1) (quote code) (assign prev 2) (eq? $ 1 $ 2) (assign prev 3) (branch $ 3 14) (quote (var-arg)) (assign prev 4) (cons $ 4 $ 0) (assign prev 5) (tailcall progn $ 5) halt (quote code) (assign prev 6) (quote (var-arg)) (assign prev 7) (cdr $ 0) (assign prev 8) (cons $ 7 $ 8) (assign prev 9) (cons $ 6 $ 9) (assign prev 10) (tailcall progn $ 10) halt) (assign prev 25) (code (assign arg# 0 0) (gosub list? $ 0) (assign prev 1) (gosub not $ 1) (assign prev 2) (branch $ 2 41) (car $ 0) (assign prev 3) (quote branch) (assign prev 4) (eq? $ 3 $ 4) (assign prev 5) (gosub not $ 5) (assign prev 6) (branch $ 6 28) (branch #t 18) ($ 0) halt (gosub drop-last $ 0) (assign prev 7) (gosub last $ 0) (assign prev 8) (gosub inc $ 8) (assign prev 9) (gosub list $ 9) (assign prev 10) (tailcall append $ 7 $ 10) halt (branch #f 31) ($ 0) halt (gosub drop-last $ 0) (assign prev 11) (gosub last $ 0) (assign prev 12) (gosub inc $ 12) (assign prev 13) (gosub list $ 13) (assign prev 14) (tailcall append $ 11 $ 14) halt (branch #f 44) ($ 0) halt (gosub drop-last $ 0) (assign prev 15) (gosub last $ 0) (assign prev 16) (gosub inc $ 16) (assign prev 17) (gosub list $ 17) (assign prev 18) (tailcall append $ 15 $ 18) halt) (assign prev 26) (gosub map $ 26 $ 0) (assign prev 27) (gosub $ 25 $ 27) (assign prev 28) (tailcall progn $ 28) halt) (assign prev 1) (make-env expression) (assign prev 2) (make-closure $ 1 $ 2) (assign prev 3) (code (assign arg# 0 0) (assign arg# 1 1) (code (assign arg# 0 0) (code (assign arg# 0 0) (env-ref ins) (assign prev 1) (gosub list? $ 1) (assign prev 2) (gosub not $ 2) (assign prev 3) (branch $ 3 153) (env-ref ins) (assign prev 4) (car $ 4) (assign prev 5) (quote code) (assign prev 6) (eq? $ 5 $ 6) (assign prev 7) (gosub not $ 7) (assign prev 8) (branch $ 8 124) (env-ref im-lmb) (assign prev 9) (gosub list? $ 9) (assign prev 10) (gosub not $ 10) (assign prev 11) (branch $ 11 95) (env-ref im-lmb) (assign prev 12) (quote ()) (assign prev 13) (eq? $ 12 $ 13) (assign prev 14) (gosub not $ 14) (assign prev 15) (gosub not $ 15) (assign prev 16) (branch $ 16 66) (branch #t 48) (env-ref im-lmb) (assign prev 17) (env-ref ins) (assign prev 18) (cons $ 18 $ 0) (assign prev 19) (gosub list $ 17 $ 19) (assign prev 20) (tailcall progn $ 20) halt (env-ref im-lmb) (assign prev 21) (cdr $ 21) (assign prev 22) (env-ref im-lmb) (assign prev 23) (car $ 23) (assign prev 24) (env-ref ins) (assign prev 25) (gosub mark-var-args $ 24 $ 25) (assign prev 26) (cons $ 26 $ 0) (assign prev 27) (gosub list $ 22 $ 27) (assign prev 28) (tailcall progn $ 28) halt (branch #f 77) (env-ref im-lmb) (assign prev 29) (env-ref ins) (assign prev 30) (cons $ 30 $ 0) (assign prev 31) (gosub list $ 29 $ 31) (assign prev 32) (tailcall progn $ 32) halt (env-ref im-lmb) (assign prev 33) (cdr $ 33) (assign prev 34) (env-ref im-lmb) (assign prev 35) (car $ 35) (assign prev 36) (env-ref ins) (assign prev 37) (gosub mark-var-args $ 36 $ 37) (assign prev 38) (cons $ 38 $ 0) (assign prev 39) (gosub list $ 34 $ 39) (assign prev 40) (tailcall progn $ 40) halt (branch #f 106) (env-ref im-lmb) (assign prev 41) (env-ref ins) (assign prev 42) (cons $ 42 $ 0) (assign prev 43) (gosub list $ 41 $ 43) (assign prev 44) (tailcall progn $ 44) halt (env-ref im-lmb) (assign prev 45) (cdr $ 45) (assign prev 46) (env-ref im-lmb) (assign prev 47) (car $ 47) (assign prev 48) (env-ref ins) (assign prev 49) (gosub mark-var-args $ 48 $ 49) (assign prev 50) (cons $ 50 $ 0) (assign prev 51) (gosub list $ 46 $ 51) (assign prev 52) (tailcall progn $ 52) halt (branch #f 135) (env-ref im-lmb) (assign prev 53) (env-ref ins) (assign prev 54) (cons $ 54 $ 0) (assign prev 55) (gosub list $ 53 $ 55) (assign prev 56) (tailcall progn $ 56) halt (env-ref im-lmb) (assign prev 57) (cdr $ 57) (assign prev 58) (env-ref im-lmb) (assign prev 59) (car $ 59) (assign prev 60) (env-ref ins) (assign prev 61) (gosub mark-var-args $ 60 $ 61) (assign prev 62) (cons $ 62 $ 0) (assign prev 63) (gosub list $ 58 $ 63) (assign prev 64) (tailcall progn $ 64) halt (branch #f 164) (env-ref im-lmb) (assign prev 65) (env-ref ins) (assign prev 66) (cons $ 66 $ 0) (assign prev 67) (gosub list $ 65 $ 67) (assign prev 68) (tailcall progn $ 68) halt (env-ref im-lmb) (assign prev 69) (cdr $ 69) (assign prev 70) (env-ref im-lmb) (assign prev 71) (car $ 71) (assign prev 72) (env-ref ins) (assign prev 73) (gosub mark-var-args $ 72 $ 73) (assign prev 74) (cons $ 74 $ 0) (assign prev 75) (gosub list $ 70 $ 75) (assign prev 76) (tailcall progn $ 76) halt) (assign prev 1) (make-env $ 0 im-lmb ins) (assign prev 2) (make-closure $ 1 $ 2) (assign prev 3) (env-ref prior) (assign prev 4) (gosub cadr $ 4) (assign prev 5) (tailcall $ 3 $ 5) halt) (assign prev 2) (make-env $ 1 ins $ 0 prior) (assign prev 3) (make-closure $ 2 $ 3) (assign prev 4) (car $ 0) (assign prev 5) (tailcall $ 4 $ 5) halt) (assign prev 4) (quote ()) (assign prev 5) (gosub list $ 0 $ 5) (assign prev 6) (env-ref assembly) (assign prev 7) (gosub foldl $ 4 $ 6 $ 7) (assign prev 8) (gosub cadr $ 8) (assign prev 9) (gosub reverse $ 9) (assign prev 10) (tailcall $ 3 $ 10) halt) (assign prev 2) (make-env $ 0 expression $ 1 assembly)
				  (assign prev 3) (make-closure $ 2 $ 3) (assign prev 4) (gosub cddr $ 0) (assign prev 5) (gosub get-immediate-lambdas $ 5) (assign prev 6) (tailcall $ 4 $ 6) halt)))

(define optimize (assemble '((assign arg# 0 0) (code (assign arg# 0 0) (atom? $ 0) (assign prev 1) (branch $ 1 23) (car $ 0) (assign prev 2) (quote code) (assign prev 3) (eq? $ 2 $ 3) (assign prev 4) (branch $ 4 13) ($ 0) halt (quote code) (assign prev 5) (gosub list $ 5) (assign prev 6) (cdr $ 0) (assign prev 7) (gosub optimize $ 7) (assign prev 8) (tailcall append $ 6 $ 8) halt ($ 0) halt) (assign prev 1) (gosub fix-assignments $ 0) (assign prev 2) (gosub fix-branches $ 2) (assign prev 3) (gosub add-gosubs $ 3) (assign prev 4) (gosub add-tailcalls $ 4) (assign prev 5) (tailcall map $ 1 $ 5) halt)))

(define to-assembly (assemble '((assign arg# 0 0) (gosub macroexpand-all $ 0) (assign prev 1) (gosub protect-var-args $ 1) (assign prev 2) (quote ()) (assign prev 3) (gosub convert-closures $ 2 $ 3) (assign prev 4) (gosub M $ 4) (assign prev 5) (gosub unfold $ 5) (assign prev 6) (gosub optimize $ 6) (assign prev 7) (tailcall mark-var-args $ 0 $ 7) halt)))

(define compile (assemble '((assign arg# 0 0) (gosub to-assembly $ 0) (assign prev 1) (assemble $ 1) halt)))


